<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014/12 | PostgreSQL DBA</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="I'm a PostgreSQL Lover and a Java Programmer.">
<meta property="og:type" content="website">
<meta property="og:title" content="PostgreSQL DBA">
<meta property="og:url" content="http://dreamer-yzy.github.io/archives/2014/12/">
<meta property="og:site_name" content="PostgreSQL DBA">
<meta property="og:description" content="I'm a PostgreSQL Lover and a Java Programmer.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PostgreSQL DBA">
<meta name="twitter:description" content="I'm a PostgreSQL Lover and a Java Programmer.">

  
    <link rel="alternative" href="/atom.xml" title="PostgreSQL DBA" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-57440117-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PostgreSQL DBA</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Zhiyong Yang</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://dreamer-yzy.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post--翻译-CTE表达式和临时表的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/12/-翻译-CTE表达式和临时表的区别/" class="article-date">
  <time datetime="2014-12-11T16:02:52.000Z" itemprop="datePublished">12月 12 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/12/-翻译-CTE表达式和临时表的区别/">[翻译]CTE表达式和临时表的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>翻译于<a href="http://dba.stackexchange.com/a/13117" target="_blank" rel="external">dba.stackexchange.com</a><br>版权归原作者所有，本人只是业余爱好翻译。</p>
<hr>
<p>这个问题是相当广泛的，但尽我所能给你一个普通的回答。</p>
<h1 id="CTEs">CTEs</h1>
<ul>
<li>不可以建索引（但可以使用引用到的对象的索引）</li>
<li>不能有约束</li>
<li>本质上是一个一次性视图</li>
<li>只在下一个执行查询时存在</li>
<li>可以递归</li>
<li>没有专门的统计状态数据（只依赖于底层对象）</li>
</ul>
<h1 id="临时表">临时表</h1>
<ul>
<li>是存在于临时数据库的真正物化的表</li>
<li>可以建索引</li>
<li>可以有约束</li>
<li>在当前连接的会话中会一直存在</li>
<li>可以被其他查询或子查询引用</li>
<li>引擎可以有专门为它准备的统计数据</li>
</ul>
<p>至于何时使用哪个，他们有不同的应用场景。如果你会有一个非常大的结果集，或者需要不上一次地引用它，那请使用临时表。如果需要使用递归，一次性，或者做一些简单的逻辑计算，那就使用CTE。</p>
<p>注意，CTE永远不应该用于性能。使用CTE并不会提高你的性能，因为，它仅仅是个一次性视图。你可以用它做一些其他的事，但是为了加快查询真的并不是它的用途。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/12/-翻译-CTE表达式和临时表的区别/" data-id="ygzqctg8386ap0gh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTE表达式/">CTE表达式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-翻译/">PostgreSQL 翻译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/临时表/">临时表</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post--翻译-MySQL与PostgreSQL9-0的复制功能对比" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/09/-翻译-MySQL与PostgreSQL9-0的复制功能对比/" class="article-date">
  <time datetime="2014-12-09T14:03:42.000Z" itemprop="datePublished">12月 9 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/PostgreSQL基础学习/">PostgreSQL基础学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/09/-翻译-MySQL与PostgreSQL9-0的复制功能对比/">[翻译]MySQL与PostgreSQL9.0的复制功能对比</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.theserverside.com/feature/Comparing-MySQL-and-Postgres-90-Replication" target="_blank" rel="external">源文地址</a></p>
<p>作者:Robin Schumacher 和 Gary Carter,EnterpriseDB 公司</p>
<p>原文:<br>Replication is one of the most popular features used in RDBMS’s today. Replication is used for disaster recovery purposes (i.e. backup or warm stand-by servers), reporting systems where query activity is offloaded onto another machine to conserve resources on the transactional server, and scale-out architectures that use sharding or other methods to increase overall query performance and data throughput.</p>
<p>翻译:<br>今天，“复制”是关系数据库的最受欢迎的功能之一。复制的目的是用于灾难恢复（也就是备份或者叫“热”备用服务器），用于在事务服务器上报告系统，将查询活动转移到其他机器，以节约资源。并且这种分区或其他方法的横向扩展构架将会提升整体的查询性能以及数据的吞吐率。</p>
<p>原文:<br>Replication is not restricted to only the major proprietary databases; open source databases such as MySQL and PostgreSQL also offer replication as a feature. While MySQL has offered built-in replication for a number of years, PostgreSQL replication used to be accomplished via community software that was an add-on to the core Postgres Server. That all changed with the release of version 9.0 of PostgreSQL, which now offers built-in streaming replication that is based on its proven write ahead log technology.</p>
<p>翻译:<br>复制功能，并不仅仅限制在专利的商业数据库，一些开源的比如：MySQL 和 PostgreSQL 也提供复制的功能。当MySQL已经内建提供复制功能好几年时，PostgreSQL的复制功能还只是社区通过附加组件形式被添加到核心PostgreSQL服务器。但是，直到PostgreSQL9.0版本时，一切都发生改变了，PostgreSQL现在提供内建一种基于WAL(预写日志）技术的流复制功能。</p>
<p>原文:<br>With the two most popular open source databases now providing built-in replication, questions are being asked about how they differ in their replication technologies. What follows is a brief overview of both MySQL and PostgreSQL replication, with a brief compare and contrast of the implementations being performed immediately afterwards.</p>
<p>翻译:<br>现在，这两个最流行的开源数据库都已经提供了内建的复制功能，那么问题来了：他们两者之间的复制功能有什么区别？下面对MySQL和PostgreSQL作一些简要概述，作一个简单的比较和它们的实现区别之后来简单实践一下。</p>
<p>原文：<br>An Overview of MySQL Replication</p>
<p>Asynchronous replication was introduced into Oracle’s MySQL with version 3.23 and today it remains the primary feature employed by many MySQL users to create scale-out architectures, standby servers, read-only data marts, and more. The various supported MySQL replication topologies include:</p>
<p>•        Single master to one slave</p>
<p>•        Single master to multiple slaves</p>
<p>•        Single master to one slave to one or more slaves</p>
<p>•        Circular replication (A to B to C and back to A)</p>
<p>•        Master to master</p>
<p>The major replication topology not currently supported in Oracle’s MySQL today is multi-source replication: having one or more master servers feed a single slave.</p>
<p>A graphical view of how MySQL replication functions can be represented as follows:</p>
<p>翻译:<br>MySQL的复制功能概要</p>
<p>异步复制在MySQL的3.23版本时就被引入了。今天，异步复制仍然是许多MySQL用户用于横向扩展、备库、只读数据等等的主要功能。MySQL支持的各种拓扑结构包括：</p>
<p>•        单主，一从</p>
<p>•        单主，多从</p>
<p>•        单主一从到多从</p>
<p>•        环形复制（A - B - C - A）</p>
<p>•        主对主</p>
<p>对于现在的MySQL主要不支持的拓扑结构是“多源复制”，也就是：拥有一个或多个主服务器，但只有一个从库。</p>
<p>MySQL复制功能的图形化表示如下：</p>
<p><img src="/img/postgresql-mysql-replication-mysql.png" alt=""></p>
<p>原文：<br>Object, data, and security operations run on the master are copied to the master server’s binary log. A user has the option of replicating an entire server, one or more databases, or just selected tables (although filtering by table is only done on the slave). The slave server obtains information from the master’s binary log over the network , copies the commands and/or data, and first applies them to the slave’s relay binary log. That log is then read by another process – the SQL thread – that applies the replicated operations/data to the slave database and its binary log.</p>
<p>翻译：<br>在主库上，对象、数据和安全的操作全部都会被复制到主库服务器的二进制日志。用户可以选择复制整个服务器、一个或多个数据库、或仅仅选择某些表来进行复制（尽管表过滤只是在从库完成）。从库通过网络传输从主库获取二进制日志信息，复制的命令或数据会首先应用到从库的 relay 二进制日志里。这个 relay 二进制日志，会被其他工具处理 —— SQL 线程，SQL线程会将replay二进制日志里复制的操作命令和数据应用到从库自己的二进制日志里。</p>
<p>原文：<br>Prior to release 5.1, MySQL replication was statement-based, meaning that the actual SQL commands were replicated from the master to one or more slaves. However, certain use cases did not lend themselves to statement-based replication (e.g. non-deterministic function calls) so in MySQL 5.1 row-based replication was introduced. A user now has the option of setting a configuration parameter to use either statement or row-based replication.</p>
<p>翻译：<br>在5.1版本之前，MySQL 复制是基于语句的，意味着实际的SQL命令是通过复制从主库到一个或多个备库中的。然而，某些使用情况不能让它们基于语句复制（例如，非确定函数调用）。所以，在MySQL 5.1版本提供了基于行复制功能。用户现在可以通过配置相应的参数来决定是使用基于语句还是基于行复制。</p>
<p>原文：<br>The primary bottleneck for busy MySQL replication configurations is the single-threaded nature of its design: replication operations are not multi-threaded at the moment, although MySQL has declared it is coming in a future release. This limitation can cause some slave servers under heavy load to get far behind the master in regards to applying binary log information.</p>
<p>翻译：<br>在繁忙时的MySQL复制配置里，主要的瓶颈是由于它自身的单线程设计性质：复制操作都不是多线程的，尽管MySQL已经声称将来会将这个多线程特性添加到未来的版本中。这个限制可能导致从库在高负载情况下应用执行二进制日志将会远远落后于主库的日志信息。</p>
<p>原文：<br>Setting up MySQL replication is a fairly painless process. Although various setup procedures exist, in general, the following is a basic outline of how it is done:</p>
<p>•      The master and slave servers are identified</p>
<p>•      The master server is modified to include a replication security account</p>
<p>•      The master server’s MySQL configuration file is modified to enable binary logging. A few other parameters are included as well (e.g. a unique server ID, type of replication such as statement or row-based, etc.)</p>
<p>•      The slave server’s MySQL configuration file is modified to include a unique server ID</p>
<p>•      The master server is restarted</p>
<p>•      The master server’s log file position is recorded</p>
<p>•      The master’s data is copied to the slave to initially seed the slave server. This can be done via a cold backup/restore, using the mysqldump utility, locking the master tables and doing a file copy, etc.</p>
<p>•      The slave server is restarted</p>
<p>•      The MySQL CHANGE MASTER command is executed on the slave server to set the master host name on the slave server as well as other parameters such as the master account username and password, the log file name, and beginning log file position</p>
<p>翻译：<br>设置MySQL的复制功能是一个非常痛苦的过程。尽管有许多种设置规则存在，但通常，以下是一些通常的步骤：</p>
<p>•      主库和从库都要标识</p>
<p>•      主库添加一个用于安全复制的账号</p>
<p>•      在主库中修改配置文件以开启二进制日志功能，还有一些其他的参数也要开启。 （比如：唯一的服务器ID， 复制的类型，等等）</p>
<p>•      在从库中修改配置文件，添加一个唯一的服务器ID。</p>
<p>•      重启主服务器</p>
<p>•      主库的日志文件位置被记录。</p>
<p>•      主库的数据将被初始化到从库中。这是通过冷备份/恢复完成的，例如使用：mysqldump 工具，锁住主库的表然后完成文件复制，等等。</p>
<p>•      重启从库</p>
<p>•      MySQL CHANGE MASTER 命令是在从库服务器上执行设置将主库的主机名以及其他的参数如：主库的用户名，密码，日志文件名以及日志文件起始位置设置到从库。</p>
<p>原文：<br>Once set up, MySQL replication is quite reliable. Being asynchronous in nature, however, there are use cases that could result in data loss between a master and slave. To help combat these situations, MySQL 5.5 introduced semi-synchronous replication where a pending transaction is sent from a master to a slave, but not committed on the slave; it merely ‘lands’ safely on the slave to be run as soon as possible. Once the master is notified that the transaction is safely recorded on the slave, then the transaction is committed on the master.</p>
<p>翻译：<br>一旦设置完毕，MySQL复制是相当可靠的。因为本质上是异步的，所以有一些使用情况下还是会导致在主库和从库之间丢失数据。为了帮助解决这个问题，MySQL 5.5 提供了“半同步”复制，它会将事务从主库发送到从库，但在从库并未提交（只是记录到relay二进制日志）。它仅仅是尽可能快速地被安全送到从库。一旦主库收到事务已经被安全地记录在从库上，然后主库才会正式提交事务。</p>
<p>原文：<br>In terms of MySQL replication limitations and missing features, besides the already mentioned single threaded nature of the implementation and the inability to perform multi-source replication, other wish-list items include a full synchronous option, conflict detection and resolution, time-delayed replication, changing the binary log to a storage engine, better replication filtering on the master, global statement ID’s, and graphical tools to manage replication functions.</p>
<p>翻译：<br>MySQL在复制功能方面有许多限制以及不足，除了之前已经提过的单线程性质，还有不能进行多源进制，其他的希望加入的特性包括：完全同步选项，冲突检测及解决办法，延时复制，更改二进制日志的存储引擎，在主库上更好的复制过滤功能，全局语句的ID标识以及管理复制函数的图形化工具。</p>
<p>原文：<br>There are third-party providers of MySQL replication solutions that overcome some of the current shortcomings in what is provided out-of-the-box with MySQL. One example is Continuent’s Tungsten product.</p>
<p>For more information about Oracle’s MySQL replication, see: <a href="http://dev.mysql.com/doc/refman/5.5/en/replication.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.5/en/replication.html</a>.</p>
<p>翻译：<br>有许多第三方提供即开即用的MySQL复制解决方案来克服当前MySQL内建复制功能的缺点。一个例子是：Continuent’s Tungsten 的数据库产品。<br>更多关于MySQL复制功能，请看：<a href="http://dev.mysql.com/doc/refman/5.5/en/replication.html." target="_blank" rel="external">MySQL5.5复制</a></p>
<p>原文：<br>An Overview of PostgreSQL Replication</p>
<p>PostgreSQL replication is based on a mature and long used technology called write ahead log (WAL) archiving.  WAL technology has been in use since version 7.1 and has been used in features such as backup and restore and warm standby servers (i.e. slave servers offline kept in synch with the master to step in during crash recovery) for high availability.</p>
<p>PostgreSQL 9.0 introduced significant enhancements producing extremely fast WAL processing that results in near real-time replication and hot standby capabilities for slave servers.  The supported PostgreSQL replication topologies include:</p>
<p>•        Single master to one slave</p>
<p>•        Single master to multiple slaves</p>
<p>A graphical view of how PostgreSQL replication functions can be represented as follows:</p>
<p>翻译：<br>PostgreSQL的复制功能概要</p>
<p>PostgreSQL 复制功能是基于一个成熟并且被长时间使用的技术，叫WAL（预写日志）归档。WAL技术已经在PostgreSQL 7.0版本被使用，并且是用在备份/恢复和热备用服务器的高可用中。（比如，从库离线【注，这里我认为是作者写错了，应该是online在线，而不是offline离线】保持与主库同步，并且在主库崩溃时介入以进行恢复）。</p>
<p>PostgreSQL9.0 版本显著地改进以产生极快的WAL日志处理，结果就是一个几乎是近实时复制并且是双机（主从）热备功能的从库。PostgreSQL支持的复制拓扑结构包括：</p>
<p>•        单主单从</p>
<p>•        单主多从</p>
<p>A graphical view of how PostgreSQL replication functions can be represented as follows:</p>
<p>PostgreSQL复制功能的图形化表示如下：</p>
<p><img src="/img/postgresql-mysql-replication-postgresql.png" alt=""></p>
<p>原文：</p>
<p>All objects and data (including schema) and security operation executed on the master are written to the WAL log directly on the slave machine for safety (avoiding complete data loss in the event of a catastrophic master failure).  WAL also ensures that no transaction is committed on the master until a successful write of the WAL log has occurred.  No filtering is currently possible (although replication with filtering is possible with the xDB Replication Server from EnterpriseDB) so a complete copy of the master is replicated on the slave.</p>
<p>翻译：<br>所有的对象和数据（包括模式）和在主库安全的操作都被写到WAL日志会立即安全地同步地从库(完全避免了在主库发生灾难时导致的数据丢失)。WAL也会确保在主库上不会有事务被提交，直到该事务已经成功地写到入WAL日志。当前版本并没有选择性复制功能（尽管选择性复制功能可能在 EnterpriseDB 的 xDB复制服务器提供了），所以主库会完整地被复制到从库。</p>
<p>原文：<br>The slave then applies the WAL log by directly rewriting the raw table data on disk, which is much faster than statement based replication.  It is also safer since statements such as:</p>
<p>INSERT INTO table (column) VALUES (SELECT function());</p>
<p>may have unexpected and inconsistent results if the function returns different values on different servers - perhaps because it involves a generated timestamp or uuid.</p>
<p>翻译：<br>从库然后直接应用磁盘上的WAL日志来重写元数据，这点比基于语句复制更加快速。并且，遇到以下这种SQL时都是安全的：</p>
<p>INSERT INTO table (column) VALUES (SELECT function());</p>
<p>如果这个function函数在主从两个不同的服务器之间产生不同的值，这可能有意想不到和不一致的结果。比如可能它调用一个产生UUID或Timestamp的函数。</p>
<p>原文：<br>The primary limitations of PostgreSQL replication are topology based.  It cannot currently do cascading replication or filter tables by rows for replication.  Again, these are capabilities available in a separate replication solution from EnterpriseDB called xDB Replication Server.</p>
<p>翻译：<br>PostgreSQL复制的主要限制是它的拓扑结构。它目前不能进行联级复制，也不能通过行来过滤表进行复制。同样，这些功能可以通过 EnterpriseDB 里单独提供一种叫 xDB 复制服务器来解决。</p>
<p>原文：<br>Setting up PostgreSQL replication is very straightforward.  WAL logging is always enabled with minimal configuration needed by the user to utilize replication. The basic process to get replication going is:</p>
<p>•      The master and slave servers are identified</p>
<p>•      The postgresql.conf file on the master is edited to turn on streaming replication</p>
<p>•      The pg_hba.conf file on the master is edited in order to let the slave connect</p>
<p>•      The recovery.conf and postgresql.conf files on the slave are edited to start up replication and hot standby</p>
<p>•      The master is shutdown and the data files are copied to the slave</p>
<p>•      The slave is started first</p>
<p>•      The master is started</p>
<p>翻译：<br>设置PostgreSQL复制是非常简单的。开启WAL日志是用户使用复制的最小化配置。使用复制的基本流程如下：</p>
<p>•      主库和从库都要标识</p>
<p>•      编辑在主库的postgresql.conf 配置文件里，以开启流复制</p>
<p>•      编辑在主库的pg_hba.conf 配置文件，以让从库连接到主库</p>
<p>•      编辑在从库的 recovery.conf 配置文件和postgresql.conf 配置文件，以开始复制和热备用</p>
<p>•      关闭主库，并且复制data目录所有文件到从库</p>
<p>•      先启动从库</p>
<p>•      再启动从库</p>
<p>原文：<br>The secret sauce to PostgreSQL 9.0’s extremely reliable WAL based replication is a set of enhancements to efficiently stream very small WAL segments compared to earlier versions.  Like MySQL there are cases where data loss could occur – however, depending on how you configure the system, your hardware architecture, and load, its possible the data loss could be as small as a single transaction.</p>
<p>PostgreSQL does not currently have native synchronous replication. However, there are multiple replication options available from other community and third-party software providers.  PostgreSQL offers multiple solutions for multi-master replication, including solutions based on two phase commit. Offerings include Bucardo, rubyrep, PgPool and PgPool-II and Tungsten Replicator as well as some proprietary solutions. Another promising approach, implementing eager (synchronous) replication is Postgres-R, however it is still in development. Yet another project implementing synchronous replication is Postgres-XC, which is a shared-nothing, transactional scale-out solution that is still under development.</p>
<p>For more information on PostgreSQL replication see:</p>
<p>PostgreSQL Documentation: <a href="http://www.enterprisedb.com/docs/en/9.0/pg/high-availability.html" target="_blank" rel="external">http://www.enterprisedb.com/docs/en/9.0/pg/high-availability.html</a></p>
<p>Bucardo: <a href="http://bucardo.org/wiki/Bucardo" target="_blank" rel="external">http://bucardo.org/wiki/Bucardo</a></p>
<p>PgPool-II: <a href="http://pgpool.projects.postgresql.org/" target="_blank" rel="external">http://pgpool.projects.postgresql.org/</a></p>
<p>Tungsten Replication: <a href="http://www.continuent.com/community/tungsten-replicator" target="_blank" rel="external">http://www.continuent.com/community/tungsten-replicator</a></p>
<p>翻译：<br>PostgreSQL9.0非常可靠的秘密武器在于基于WAL日志复制，它是一套增强的高效流，利用非常小的一段WAL来进行早期版本的比较。像MySQL在有些情况下可能会导致数据丢失，然而，这取决于你的系统、你的硬件构架以及负载如何，它丢失的数据可能非常小，如：一个事务的数据。</p>
<p>PostgreSQL目前还没有本地同步复制。然而，有许多种通过社区和第三方软件提供商提供的可用复制方案。PostgreSQL 提供许多“多主复制”的解决方案，包括基于两阶段提交的解决方案。包括：Bucardo, rubyrep, PgPool and PgPool-II and Tungsten Replicator 以及其他一些专有的解决方案。另一种非常有前景的解决办法，实现 饥饿（同步）复制的Postgres-R产品，然而，它目前还在开发中。还有另一个项目实现同步复制的是Postgres-XC，它是一个无共享、事务横向扩展的解决方案，目前也是处于开发中。</p>
<p>更多关于PostgreSQL复制，请看：<br>PostgreSQL 文档: <a href="http://www.enterprisedb.com/docs/en/9.0/pg/high-availability.html" target="_blank" rel="external">http://www.enterprisedb.com/docs/en/9.0/pg/high-availability.html</a></p>
<p>Bucardo: <a href="http://bucardo.org/wiki/Bucardo" target="_blank" rel="external">http://bucardo.org/wiki/Bucardo</a></p>
<p>PgPool-II: <a href="http://pgpool.projects.postgresql.org/" target="_blank" rel="external">http://pgpool.projects.postgresql.org/</a></p>
<p>Tungsten Replication: <a href="http://www.continuent.com/community/tungsten-replicator" target="_blank" rel="external">http://www.continuent.com/community/tungsten-replicator</a></p>
<p>原文：<br>A Brief Compare and Contrast of MySQL and PostgreSQL Replication</p>
<p>Those wanting to use an open source database for a particular application project that requires replication have two good choices in MySQL and PostgreSQL. But, the question naturally arises, which should be used? Is one just as good as the other?</p>
<p>As demonstrated above, there are both feature and functional differences between how MySQL and PostgreSQL implement replication. However, for many general application use cases, either MySQL or PostgreSQL replication will serve just fine; technically speaking, from a functional and performance perspective, it won’t matter which solution is chosen. That said, there still are some considerations to keep in mind in deciding between the different offerings. Some of these include the following:</p>
<p>•      Oracle’s MySQL offers both statement and row-based replication, whereas PostgreSQL only uses the latter based on write ahead log information. There are pro’s and con’s to using statement-based replication, which MySQL has documented here: <a href="http://dev.mysql.com/doc/refman/5.5/en/replication-sbr-rbr.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.5/en/replication-sbr-rbr.html</a>. It is generally acknowledged that row or WAL-based replication is the safest and most reliable form of replication. It does, however, result in larger log files for MySQL than the statement-based option does.</p>
<p>•      MySQL currently supports more replication topologies than PostgreSQL (e.g. ring, etc.). However PostgreSQL does have a number of community supported replication offerings that help close this gap (e.g. Bucardo’s master-to-master solution).</p>
<p>•      In regard to data loss, MySQL 5.5 offers the semi-synchronous option, which helps minimize the risk of master-slave synchronization problems due to a master server going down. For PostgreSQL, a full synchronous replication option is in development and scheduled for release sometime in 2011.</p>
<p>•      As to replication filtering, MySQL provides filtering on the slave server, whereas with PostgreSQL, no filtering is available; in other worlds, the entire database from the master is replicated to the slave. With MySQL, all the information is sent, but then options exist to selectively apply the replicated events on the slave. However, as the MySQL binary log is not used for crash recovery purposes in the same way as PostgreSQL’s WAL is, a user can configure a MySQL master so only certain databases are logged and, in that sense, a filter for the master server is available.</p>
<p>•      Both MySQL and PostgreSQL replication are single-threaded at the current time.</p>
<p>•      With respect to monitoring replication, MySQL provides a number of SHOW commands to understand the state of replication between a master and slave. To date, PostgreSQL offers functions to compute the differences in log positions between the master and slave servers, but that is all that is currently provided in 9.0.</p>
<p>•      For failover and load balancing, the PostgreSQL community provides pgPool, which is middleware that provides connection pooling, load balancing, failover, and more between replicated servers. MySQL 5.5 supports connection pooling in the Enterprise edition, but failover and load balancing must be handled via a third-party product or custom development.</p>
<p>翻译：<br>简单对比一下MySQL和PostgreSQL复制</p>
<p>那些想为一个需要复制功能的特定应用的项目使用开源数据库的人，MySQL和PostgreSQL是两个很好的选择。但是，问题自然而然产生了，我们应该使用哪个？还是说这两个一样好？</p>
<p>综上所述，MySQL和PostgreSQL都有复制功能，但是有不同的实现。然而，对于一般的应用来说，无论是MySQL还是PostgreSQL复制功能会工作得挺好；从技术上说，以及从功能和性能来看，它不会不管要选哪个数据库。这意味着，在不同产品之间还有一些值得注意的事项，其中包括以下内容：</p>
<p>•  MySQL提供基于语句和基于行的复制，而PostgreSQL只有基于WAL日志信息。有赞成也有反对使用基于语句复制的，MySQL有文档介绍：<a href="http://dev.mysql.com/doc/refman/5.5/en/replication-sbr-rbr.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.5/en/replication-sbr-rbr.html</a> 。一般认为，基于行或基于WAL 复制是最安全和最可靠的复制形式。的确如此，然而，这会导致比基于语句复制的形式产生更大的日志文件。</p>
<p>•  MySQL目前比PostgreSQL支持更加多的复制拓扑结构（比如：环形等）。然而，PostgreSQL有许多种社区支持的复制选项，这就缩小了这个因拓扑结构种类而导致的距离（比如 Bucardo 的 主-主解决方案）</p>
<p>•  考虑到数据丢失，MySQL 5.5 提供了半同步选项，这有助于减小因主库崩溃而导致主从同步问题的风险。对于PostgreSQL，完全同步复制特性正在开发，并且计划于2011年正式可用。</p>
<p>•  对于过滤复制，MySQL 提供了在从库过滤，而在PostgreSQL，并不能使用过滤，换句话说，就是完整地将数据库从主库复制到从库。对于MySQL，所有信息都会被发送到从库，但如果开启过滤复制，从库会有选择地将事件应用到从库。然而，对于MySQL二进制日志并不是用于灾难恢复的，但PostgreSQL的WAL是可以用于灾难恢复的，用户可以配置MySQL主库指定哪些数据库会被记录到日志，在这种意义上，过滤器对于主库是可用的。</p>
<p>•  目前，MySQL和PostgreSQL复制都是单线程的</p>
<p>•  对于复制的监控，MySQL提供了许多 SHOW 命令去了解主从复制的状态。至今，PostgreSQL提供一些函数去计算主从日志位置的区别，但是当前只是在PostgreSQL9.0版本才提供的。</p>
<p>• 对于故障切换和负载均衡，PostgreSQL社区提供pgPool的中间件，pgPool提供连接池，负载均衡，故障切换和更多种复制形式。MySQL 5.5 在企业版里提供连接池，但是对于故障切换和负载均衡必须通过第三方产品或定制开发。</p>
<p>原文：<br>Conclusions</p>
<p>As was previously stated, for many application use cases, both Oracle’s MySQL and PostgreSQL replication will be an equally good choice. The best way to determine which is right for you is to download both and put each through a comprehensive evaluation.</p>
<p>You can download Oracle’s MySQL at <a href="http://www.mysql.com/downloads/" target="_blank" rel="external">http://www.mysql.com/downloads/</a>, while both community and EnterpriseDB’s offerings of PostgreSQL can be found at: <a href="http://www.enterprisedb.com/products/download.do" target="_blank" rel="external">http://www.enterprisedb.com/products/download.do</a>.</p>
<p>By Robin Schumacher and Gary Carter, www.enterprisedb.com</p>
<p>18 Nov 2010</p>
<p>翻译：<br>结论</p>
<p>正如前面所指出一样，对于许多应用程序的用例，MySQL和PostgreSQL都是非常好的选择。要决定哪一个最适合你，最好的办法就是同时下载它们两个，然后使用进行综合评估。</p>
<p>你可以在 <a href="http://www.mysql.com/downloads/" target="_blank" rel="external">http://www.mysql.com/downloads/</a> 下载MySQL，PostgreSQL的社区版和EnterpriseDB提供的PostgreSQL版本都可以在这个地址里找到：<a href="http://www.enterprisedb.com/products/download.do" target="_blank" rel="external">http://www.enterprisedb.com/products/download.do</a> </p>
<p>作者：Robin Schumacher and Gary Carter, www.enterprisedb.com<br>18 Nov 2010</p>
<hr>
<p>注：版权是原作者所有，我只是出于业余爱好进行翻译。</p>
<p>这也是我的处女版翻译文章，有许多不足或表达不清晰的地方，恳请各位指出，我会加以修改，一起为开源、为PostgreSQL作出一份力量。<br>于2014年12月9号星期二晚，广州</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/09/-翻译-MySQL与PostgreSQL9-0的复制功能对比/" data-id="3n6q4kbju1fmcb6n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-基础学习/">PostgreSQL 基础学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-翻译/">PostgreSQL 翻译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PostgreSQL窗口函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/08/PostgreSQL窗口函数/" class="article-date">
  <time datetime="2014-12-08T13:05:48.000Z" itemprop="datePublished">12月 8 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/PostgreSQL基础学习/">PostgreSQL基础学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/08/PostgreSQL窗口函数/">PostgreSQL窗口函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是窗口函数">什么是窗口函数</h2>
<p><a href="http://www.postgresql.org/docs/9.3/static/functions-window.html" target="_blank" rel="external">PostgreSQL窗口函数</a></p>
<blockquote>
<p>窗口函数提供跨行相关的当前查询行集执行计算的能力。仅当调用跟着OVER子句的聚集函数，作为窗口函数；否则它们作为常规的聚合函数。</p>
<p>我个人的理解：窗口也是一种分组，但和 group by 的分组不同。窗口，可以提供分组之外，还可以执行对每个窗口进行计算。可以相像成是group by 后，然后对每个分组进行计算，而不像Group by ，只是单纯地分组。</p>
</blockquote>
<h2 id="窗口函数的语法">窗口函数的语法</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function_name ([expression [, expression <span class="keyword">...</span> ]]) OVER window_name</div><div class="line">function_name ([expression [, expression <span class="keyword">...</span> ]]) OVER ( window_definition )</div><div class="line">function_name ( * ) OVER window_name</div><div class="line">function_name ( * ) OVER ( window_definition )</div></pre></td></tr></table></figure>

<blockquote>
<p>窗口函数的调用总是包含一个OVER子句，即窗口函数的名称和参数。 该语法区别于普通函数或聚合功能。OVER子句决定究竟将 查询的行如何通过窗口函数拆分处理。OVER子句内的PARTITION BY分区指定 行划分成组，或分区，共享相同的PARTITION BY值。 对于每一行，窗口函数通过同一个分区作为当前行的行进行计算</p>
<p>如果OVER不使用PARTITION BY时即代表整个表。</p>
</blockquote>
<h2 id="典型的窗口函数用法">典型的窗口函数用法</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">select</span> path, cost, <span class="keyword">sum</span>(cost) over (<span class="keyword">partition</span> <span class="keyword">by</span> path ) <span class="keyword">as</span> sum_cost <span class="keyword">from</span> tcost;</span></div></pre></td></tr></table></figure>

<h2 id="内置的窗口函数">内置的窗口函数</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Function</th>
<th style="text-align:left">Return Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">row_number() 行号</td>
<td style="text-align:left">bigint</td>
<td>number of the current row within its partition, counting from 1 。返回当前窗口的行数，计数从1开始。主要就是遇到相同排名时的区别，即相同的数值，排名是不同的，而且也不是确定的。</td>
</tr>
<tr>
<td style="text-align:left">rank() 排名（保持间隔）</td>
<td style="text-align:left">bigint</td>
<td>rank of the current row with gaps; same as row_number of its first peer。当前窗口中，相同的数值排名是相同的，但是还是会保留间隔的。比如：1，1，3。如果是 row_number 会是 1，2，3。也可能是：1，2，3这样子下去，这个看数据是否有相同。</td>
</tr>
<tr>
<td style="text-align:left">dense_rank() 排名（不保持间隔）</td>
<td style="text-align:left">bigint</td>
<td>rank of the current row without gaps; this function counts peer groups。这个函数与 rank() 一样，只是它不会保持间隔的，相同的数据在同一排名，然后会是下一个排名。如：1,1,2,3,3,4等。</td>
</tr>
<tr>
<td style="text-align:left">percent_rank() 排名的百分比</td>
<td style="text-align:left">double precision</td>
<td>relative rank of the current row: (rank - 1) / (total rows - 1)。这条是得出结果的公式。可知相同的排名，结果是一样的。</td>
</tr>
<tr>
<td style="text-align:left">cume_dist()</td>
<td style="text-align:left">double precision</td>
<td>relative rank of the current row: (number of rows preceding or peer with current row) / (total rows)。即小于等于当前行值的行数/总行数。结果为 0&lt;结果&lt;=1</td>
</tr>
<tr>
<td style="text-align:left">ntile(num_buckets integer) 可以将结果集放到我们指定数目的组中</td>
<td style="text-align:left">integer</td>
<td>integer ranging from 1 to the argument value, dividing the partition as equally as possible。组的数目从1开始计。分组的依据：1,每组的记录数不能大于它上一组的记录数。2,所有组中的记录要么都相同，要么从某组开始后面所有组的记录数都与该组的记录数相同</td>
</tr>
<tr>
<td style="text-align:left">lag(value any [, offset integer [, default any ]])</td>
<td style="text-align:left">same type as value</td>
<td>returns value evaluated at the row that is offset rows before the current row within the partition; if there is no such row, instead return default. Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to null 。向前获得相对于当前记录指定距离的那条记录的数据</td>
</tr>
<tr>
<td style="text-align:left">lead(value any [, offset integer [, default any ]])</td>
<td style="text-align:left">same type as value</td>
<td>returns value evaluated at the row that is offset rows after the current row within the partition; if there is no such row, instead return default. Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to null。向后获得相对于当前记录指定距离的那条记录的数据</td>
</tr>
<tr>
<td style="text-align:left">first_value(value any)</td>
<td style="text-align:left">same type as value</td>
<td>returns value evaluated at the row that is the first row of the window frame。获取当前窗口的第一个值。</td>
</tr>
<tr>
<td style="text-align:left">last_value(value any)</td>
<td style="text-align:left">same type as value</td>
<td>returns value evaluated at the row that is the last row of the window frame 。获取当前窗口的最后一个值。</td>
</tr>
<tr>
<td style="text-align:left">nth_value(value any, nth integer)</td>
<td style="text-align:left">same type as value</td>
<td>returns value evaluated at the row that is the nth row of the window frame (counting from 1); null if no such row。获取窗口中第N个值。</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/08/PostgreSQL窗口函数/" data-id="hsamxqh2rruhmj3d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-基础学习/">PostgreSQL 基础学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PostgreSQL选择某组sum结果最小的所有数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/05/PostgreSQL选择某组sum结果最小的所有数据/" class="article-date">
  <time datetime="2014-12-05T13:46:10.000Z" itemprop="datePublished">12月 5 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/PostgreSQL基础学习/">PostgreSQL基础学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/05/PostgreSQL选择某组sum结果最小的所有数据/">PostgreSQL选择某组sum结果最小的所有数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 PostgreSQL 技术群里，今天发现有个人在群里“求救”，说想要执行一条SQL语句，获取某表中以某字段为组，并且sum（其他字段）结果最小的，所有结果。</p>
<p>比如，有张表如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">path</span>(int)  <span class="function">cost</span>(<span class="value">decimal</span>)</div></pre></td></tr></table></figure>

<p>想要的结果是，以path所有相同的字段分组，并且 sum(cost)字段，选择出sum(cost)值最小的，所有path字段。如：</p>
<p><img src="/img/postgresql-sum-window-fucntion.png" alt=""></p>
<h2 id="我写的SQL：">我写的SQL：</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">with cte as (<span class="operator"><span class="keyword">select</span> path, cost, <span class="keyword">sum</span>(cost) over (<span class="keyword">partition</span> <span class="keyword">by</span> path ) <span class="keyword">as</span> sum_cost <span class="keyword">from</span> tcost)</span></div><div class="line"><span class="keyword">select</span> path , cost <span class="keyword">from</span> cte <span class="keyword">where</span> sum_cost = (<span class="keyword">select</span> <span class="keyword">min</span>(sum_cost) <span class="keyword">from</span> cte);</div></pre></td></tr></table></figure>

<h4 id="我的解题思路">我的解题思路</h4>
<p>在没有接触到PostgreSQL之前，我一直使用MySQL，每次想到“组”这个字，总会想到 group by 。虽然可能使用group by 也可能实现相同的结果，但是经常需要表自身join表，所以性能方面对于数据量大的表话，是满足不了要求的，即使是有索引。因为索引最适合于那种存在索引，而且选择率低的表，否则的话，索引的优势其实和全表扫描差不多，甚至有时候，常常是全表扫描比索引的全表扫描性能还要好。（当然，在PostgreSQL中，如果是只读索引来扫描的话，性能是最好的）。因为MySQL的 InnoDB 是索引组织表，所以索引全表和普通的全表扫描，性能几乎是没有差别。但是在PostgreSQL中，这种差别就很明显了，选择率大的索引全表扫描，比顺序全表扫描SeqScan慢好多。</p>
<p>说远了，回到题目上来。这思路虽然也是要分组，但这种分组跟group by 的分组差得比较远，这种需要一种“窗口函数”（Window Function，在Oracle里叫分析函数）来处理这钟需求，而且这种窗口函数的性能是比那种需要自表连接的性能快好多的，即使是没有索引情况下。之前在群里也遇到这种情况，利用窗口函数几秒钟就可以出结果，但那种自连接的（特别在数据量大的情况下）要几十分钟。这种窗口分组来处理数据，可以避免好多性能问题，而且非常易于理解。</p>
<p>所以，对于PostgreSQL，一有那种需要那种类似窗口的分组操作，首先要想到 Window Function，真的是非常好用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/05/PostgreSQL选择某组sum结果最小的所有数据/" data-id="7lzdf6uj6n8sq5b0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-基础学习/">PostgreSQL 基础学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-案例/">PostgreSQL 案例</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PostgreSQL-进程构架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/04/PostgreSQL-进程构架/" class="article-date">
  <time datetime="2014-12-04T12:34:53.000Z" itemprop="datePublished">12月 4 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/PostgreSQL基础学习/">PostgreSQL基础学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/04/PostgreSQL-进程构架/">PostgreSQL 进程构架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ps_aux_|_grep_postgres">ps aux | grep <strong>postgres</strong></h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">postgres <span class="number">31964</span>  <span class="number">0.0</span>  <span class="number">0.3</span> <span class="number">162180</span> <span class="number">12436</span> pts/<span class="number">0</span>    S    <span class="number">18</span>:<span class="number">09</span>   <span class="number">0</span>:<span class="number">00</span> /usr/<span class="built_in">local</span>/pg/bin/postgres -D /usr/<span class="built_in">local</span>/pg/data</div><div class="line">postgres <span class="number">31966</span>  <span class="number">0.0</span>  <span class="number">0.0</span> <span class="number">162312</span>  <span class="number">2192</span> ?        Ss   <span class="number">18</span>:<span class="number">09</span>   <span class="number">0</span>:<span class="number">00</span> postgres: checkpointer <span class="built_in">process</span>                  </div><div class="line">postgres <span class="number">31967</span>  <span class="number">0.0</span>  <span class="number">0.0</span> <span class="number">162180</span>  <span class="number">1820</span> ?        Ss   <span class="number">18</span>:<span class="number">09</span>   <span class="number">0</span>:<span class="number">00</span> postgres: writer <span class="built_in">process</span>                       </div><div class="line">postgres <span class="number">31968</span>  <span class="number">0.0</span>  <span class="number">0.0</span> <span class="number">162180</span>   <span class="number">960</span> ?        Ss   <span class="number">18</span>:<span class="number">09</span>   <span class="number">0</span>:<span class="number">00</span> postgres: wal writer <span class="built_in">process</span>                   </div><div class="line">postgres <span class="number">31969</span>  <span class="number">0.0</span>  <span class="number">0.0</span> <span class="number">163032</span>  <span class="number">2064</span> ?        Ss   <span class="number">18</span>:<span class="number">09</span>   <span class="number">0</span>:<span class="number">00</span> postgres: autovacuum launcher <span class="built_in">process</span>           </div><div class="line">postgres <span class="number">31970</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">18000</span>   <span class="number">948</span> ?        Ss   <span class="number">18</span>:<span class="number">09</span>   <span class="number">0</span>:<span class="number">00</span> postgres: stats collector <span class="built_in">process</span></div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">postgre<span class="variable">s:</span> logger proces<span class="variable">s:</span>  在PostgreSQL中称为SysLogger(<span class="number">8.0</span>)，用于整个系统的日志输出；</div><div class="line">postgre<span class="variable">s:</span> checkpointer proces<span class="variable">s:</span>  在PostgreSQL中称为Checkpointer(<span class="number">9.2</span>），用于处理checkpoints；</div><div class="line">postgre<span class="variable">s:</span> writer proces<span class="variable">s:</span>  在PostgreSQL中称为BgWriter，用于将脏页刷出到磁盘；</div><div class="line">postgre<span class="variable">s:</span> wal writer proces<span class="variable">s:</span>  在PostgreSQL中称为WalWriter(<span class="number">8.3</span>)，处理预写日志输出；</div><div class="line">postgre<span class="variable">s:</span> autovacuum launcher proces<span class="variable">s:</span>   在PostgreSQL中称为AutoVacuum(<span class="number">8.1</span>)，用于系统的自动清理；</div><div class="line">postgre<span class="variable">s:</span> archiver proces<span class="variable">s:</span>  在PostgreSQL中称为PgArch，用于预写日志归档；</div><div class="line">postgre<span class="variable">s:</span> stats collector proces<span class="variable">s:</span>  在PostgreSQL中称为PgStat，用于统计数据收集。</div></pre></td></tr></table></figure>

<p><img src="/img/postgres-process-arch.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/04/PostgreSQL-进程构架/" data-id="fbu3eoadyglugs0y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-基础学习/">PostgreSQL 基础学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PostgreSQL基础学习（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/03/PostgreSQL基础学习（一）/" class="article-date">
  <time datetime="2014-12-03T15:14:47.000Z" itemprop="datePublished">12月 3 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/PostgreSQL基础学习/">PostgreSQL基础学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/03/PostgreSQL基础学习（一）/">PostgreSQL基础学习（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介">简介</h2>
<p><a href="http://www.postgresql.org/" target="_blank" rel="external">PostgreSQL官网</a></p>
<blockquote>
<p>PostgreSQL 官网号称：它是最世界最先进的开源数据库（顺便说一下，MySQL官网说它自己是最流行的开源数据库）。我觉得这一句话，也已经非常足够概括 PostgreSQL 了（MySQL 官网的那句话，也概括了它自己的特点，一个是最先进，一个是最流行）。也有号称是 Oracle 的开源版，因为PostgreSQL被经常拿来与Oracle这个重量级的商业数据库比较。的确，PostgreSQL 与 Oracle 兼容性非常强，Oracle 的 DBA 可以非常快地上手 PostgreSQL。在 PostgreSQL 技术群里的大牛大多都是从 Oracle 转到 PostgreSQL，使我印象非常深刻就是 <a href="http://blog.163.com/digoal@126/" target="_blank" rel="external">@德哥</a>，绝对是PostgreSQL的大神级别。我也是跟着德哥的视频一边看，一边学习的。</p>
</blockquote>
<h2 id="安装（以_Ubuntu_下源码安装_PostgreSQL_9-3-5_为例）">安装（以 Ubuntu 下源码安装 PostgreSQL 9.3.5 为例）</h2>
<h4 id="下载">下载</h4>
<p><a href="http://www.postgresql.org/ftp/source/" target="_blank" rel="external">PostgreSQL 源码下载地址</a></p>
<h4 id="安装与使用">安装与使用</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#安装必要的编译环境</div><div class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> build-essential libreadline-dev</span></div><div class="line"></div><div class="line">#解压</div><div class="line">tar -xvjf postgresql-<span class="number">9.3</span><span class="number">.5</span>.tar.bz2</div><div class="line"></div><div class="line">#创建一个目录，将PostgreSQL安装到这个目录</div><div class="line">sudo mkdir /usr/<span class="keyword">local</span>/pg</div><div class="line"></div><div class="line">#配置</div><div class="line">cd postgresql-<span class="number">9.3</span><span class="number">.5</span></div><div class="line">./configure <span class="comment">--prefix=/usr/local/pg</span></div><div class="line"></div><div class="line">#开始编译</div><div class="line">make -j</div><div class="line">-j：开启多核编译</div><div class="line">如果有：<span class="keyword">All</span> <span class="keyword">of</span> PostgreSQL successfully made. Ready <span class="keyword">to</span> <span class="keyword">install</span>. 表示编译成功</div><div class="line"></div><div class="line">#安装</div><div class="line">sudo make <span class="keyword">install</span></div><div class="line">如果出现：PostgreSQL installation complete. 表示安装成功</div><div class="line"></div><div class="line">#添加 PostgreSQL 用户</div><div class="line">sudo useradd -s /<span class="keyword">bin</span>/bash -d /home/postgres postgres</div><div class="line"></div><div class="line">#创建 PostgreSQL 的 <span class="keyword">data</span> 数据目录</div><div class="line">sudo mkdir /usr/<span class="keyword">local</span>/pg/<span class="keyword">data</span> -p</div><div class="line"></div><div class="line">#修改拥有者身份</div><div class="line">sudo chown postgres:postgres /usr/<span class="keyword">local</span>/pg/ -R</div><div class="line"></div><div class="line">#初始化数据库</div><div class="line">su - postgres</div><div class="line">/usr/<span class="keyword">local</span>/pg/<span class="keyword">bin</span>/initdb -D /usr/<span class="keyword">local</span>/pg/<span class="keyword">data</span></div><div class="line"></div><div class="line">#启动数据库</div><div class="line">/usr/<span class="keyword">local</span>/pg/<span class="keyword">bin</span>/postgres -D /usr/<span class="keyword">local</span>/pg/<span class="keyword">data</span> &gt;<span class="keyword">logfile</span> <span class="number">2</span>&gt;&<span class="number">1</span> &</div><div class="line">或者</div><div class="line">/usr/<span class="keyword">local</span>/pg/<span class="keyword">bin</span>/pg_ctl -D /usr/<span class="keyword">local</span>/pg/<span class="keyword">data</span> -l <span class="keyword">logfile</span> <span class="keyword">start</span></div><div class="line"></div><div class="line">#创建数据库</div><div class="line">/usr/<span class="keyword">local</span>/pg/<span class="keyword">bin</span>/createdb test</div><div class="line"></div><div class="line">#连接数据库</div><div class="line">/usr/<span class="keyword">local</span>/pg/<span class="keyword">bin</span>/psql test</div></pre></td></tr></table></figure>

<h4 id="配置环境变量">配置环境变量</h4>
<blockquote>
<p>为了避免每次使用绝对路径以及一些参数问题，可以使用一些环境变量来代替，PostgreSQL 在没有指定参数时，就会读取这些环境变量的值</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">vi /home/postgres/.bash_profile</div><div class="line"></div><div class="line"><span class="comment">#这个是默认的PostgreSQL端口</span></div><div class="line"><span class="keyword">export</span> PGPORT=<span class="number">5432</span></div><div class="line"></div><div class="line"><span class="comment">#这个是PostgreSQL数据目录</span></div><div class="line"><span class="keyword">export</span> PGDATA=/usr/local/pg/data</div><div class="line"></div><div class="line"><span class="comment">#所使用的语言</span></div><div class="line"><span class="keyword">export</span> LANG=en_US.utf8</div><div class="line"></div><div class="line"><span class="comment">#PostgreSQL 安装目录</span></div><div class="line"><span class="keyword">export</span> PGHOME=/usr/local/pg</div><div class="line"></div><div class="line"><span class="comment">#PostgreSQL 连接库文件</span></div><div class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=<span class="variable">$PGHOME</span>/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib:<span class="variable">$LD_LIBRARY_PATH</span></div><div class="line"><span class="keyword">export</span> DATE=`date +<span class="string">"%Y%m%d%H%M"</span>`</div><div class="line"></div><div class="line"><span class="comment">#将PostgreSQL的命令行工具添加到 PATH 环境变量 ，这样子就不用每次使用绝对路径了</span></div><div class="line"><span class="keyword">export</span> PATH=<span class="variable">$PGHOME</span>/bin:<span class="variable">$PATH</span></div><div class="line"></div><div class="line"><span class="comment">#PostgreSQL的 man 手册</span></div><div class="line"><span class="keyword">export</span> MANPATH=<span class="variable">$PGHOME</span>/share/man:<span class="variable">$MANPATH</span></div><div class="line"></div><div class="line"><span class="comment">#PostgreSQL的默认用户</span></div><div class="line"><span class="keyword">export</span> PGUSER=postgres</div><div class="line"></div><div class="line"><span class="comment">#这个是PostgreSQL默认主机地址</span></div><div class="line"><span class="keyword">export</span> PGHOST=<span class="number">127.0</span>.<span class="number">0.1</span></div><div class="line"></div><div class="line"><span class="comment">#连接数据库时默认的数据库名</span></div><div class="line"><span class="keyword">export</span> PGDATABASE=postgre</div></pre></td></tr></table></figure>

<p><a href="http://www.postgresql.org/docs/9.3/static/libpq-envars.html" target="_blank" rel="external">PostgreSQL所有环境变量</a></p>
<h4 id="PostgreSQL_的_bin_目录常用工具说明">PostgreSQL 的 bin 目录常用工具说明</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#clusterdb</span></div><div class="line"> </div><div class="line">     — 对一个PostgreSQL数据库进行建簇</div><div class="line"> </div><div class="line"><span class="preprocessor">#createdb</span></div><div class="line"> </div><div class="line">    — 创建一个新的 PostgreSQL 数据库</div><div class="line"> </div><div class="line"><span class="preprocessor">#createlang</span></div><div class="line"> </div><div class="line">    — 定义一种新的 PostgreSQL 过程语言</div><div class="line"> </div><div class="line"><span class="preprocessor">#createuser</span></div><div class="line"> </div><div class="line">     — 定义一个新的 PostgreSQL 用户帐户</div><div class="line"> </div><div class="line"><span class="preprocessor">#dropdb</span></div><div class="line"> </div><div class="line">     — 删除一个现有 PostgreSQL 数据库</div><div class="line"> </div><div class="line"><span class="preprocessor">#droplang</span></div><div class="line"> </div><div class="line">    — 删除一种 PostgreSQL 过程语言</div><div class="line"> </div><div class="line"><span class="preprocessor">#dropuser</span></div><div class="line"> </div><div class="line">    — 删除一个 PostgreSQL 用户帐户</div><div class="line"> </div><div class="line"><span class="preprocessor">#ecpg</span></div><div class="line"> </div><div class="line">    — 嵌入的<span class="constant"> SQL </span>C 预处理器</div><div class="line"> </div><div class="line"><span class="preprocessor">#pg_basebackup</span></div><div class="line"> </div><div class="line">    -- 做一个PostgreSQL集群的基础备份</div><div class="line"> </div><div class="line"><span class="preprocessor">#pg_config</span></div><div class="line"> </div><div class="line">    — 检索已安装版本的 PostgreSQL 的信息</div><div class="line"> </div><div class="line"><span class="preprocessor">#pg_dump</span></div><div class="line"> </div><div class="line">    — 将一个PostgreSQL数据库抽出到一个脚本文件或者其它归档文件中</div><div class="line"> </div><div class="line"><span class="preprocessor">#pg_dumpall</span></div><div class="line"> </div><div class="line">    — 抽出一个 PostgreSQL 数据库集群到脚本文件中</div><div class="line"> </div><div class="line"><span class="preprocessor">#pg_restore</span></div><div class="line"> </div><div class="line">    — 从一个由 pg_dump 创建的备份文件中恢复 PostgreSQL 数据库。</div><div class="line"> </div><div class="line"><span class="preprocessor">#psql</span></div><div class="line"> </div><div class="line">    — PostgreSQL 交互终端</div><div class="line"> </div><div class="line"><span class="preprocessor">#reindexdb</span></div><div class="line"> </div><div class="line">    -- 重新建立一个数据库索引</div><div class="line"> </div><div class="line"><span class="preprocessor">#vacuumdb</span></div><div class="line"> </div><div class="line">    — 收集垃圾并且分析一个PostgreSQL 数据库</div><div class="line"> </div><div class="line"><span class="preprocessor">#pg_receivexlog</span></div><div class="line"> </div><div class="line">    从另一台运行PG的数据库里接收 wal 日志</div><div class="line"> </div><div class="line"><span class="preprocessor">#pg_resetxlog</span></div><div class="line"> </div><div class="line">    重置一个 PostgreSQL 数据库集群的预写日志以及其它控制内容</div></pre></td></tr></table></figure>

<h4 id="PostgreSQL_的_data_目录说明">PostgreSQL 的 data 目录说明</h4>
<p><img src="/img/postgresql-data-dir.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/03/PostgreSQL基础学习（一）/" data-id="twng9l5p4oikrd91" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-基础学习/">PostgreSQL 基础学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《数据库查询优化器的艺术》第三章物理查询优化学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/03/《数据库查询优化器的艺术》第三章物理查询优化学习笔记/" class="article-date">
  <time datetime="2014-12-03T14:09:15.000Z" itemprop="datePublished">12月 3 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/03/《数据库查询优化器的艺术》第三章物理查询优化学习笔记/">《数据库查询优化器的艺术》第三章物理查询优化学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="代价模型">代价模型</h1>
<pre><code>总代价 = IO 代价 + <span class="built_in">CPU</span> 代价
COST = P * a_page_cpu_time + W * T

P：计划运行时访问的页数，a_page_cpu_time 是每个页读取的时间花费，其积反映了IO代价
T：访问的元组。反映了<span class="built_in">CPU</span>花费。（存储层是以页面为单位，数据以页面的形式读入内存，每个页面上可能有多个元组，访问元组需要解析元组结构，才能把元组上的字段读出，这消耗的是<span class="built_in">CPU</span>）。如果是索引扫描，则还会包括索引读取的花费。
W：权重因子。表明IO到<span class="built_in">CPU</span>的相关性，又称选择率（selectivity）。选择率用于表示在关系R中，满足条件“A&lt;op&gt;a”的元组数与R的所有元组N的比值。
</code></pre><h1 id="单表扫描算法">单表扫描算法</h1>
<pre><code>全表扫描，局部扫描。单表扫描与IO操作密切相关。

1）顺序扫描（SeqScan）。当无索引可用，或访问表中的大部分数据，或表的数据量很小时，使用顺序扫描效果较好。

2）索引扫描（IndexScan）。根据索引键读索引，找出物理元组的位置。【如果选择率很高，不适宜使用索引扫描】

3）只读索引扫描（IndexOnlyScan）。根据索引键读索引，索引中的数据能够满足条件判断，不需要读取数据页面。比索引扫描少了读取数据的IO花费。

4）行扫描（RowIdScan）。用于直接定位表中的某一行。对于元组，通常为元组增加特殊的列，通过特殊的列计算出元组r物理位置，然后直接读取元组对应的页面，获取元组。在PostgreSQL中称为【Tid】扫描，此种方式是在元组头上增加名为【CTID】的列，用这列的值可直接计算本条元组的物理存储位置。

5）并行表扫描（ParallelTableScan）。对同一个表，并行地、通过顺序的方式获取表的数据，结果是得到一个完整的表数据。

6）并行索引扫描（ParallelIndexScan）。对同一个表，并行地、通过索引的方式获取表的数据，将结果合并在一起。

7）组合多个索引扫描（MultipleIndexScan）。
</code></pre><h1 id="顺序扫描代价估算公式">顺序扫描代价估算公式</h1>
<pre><code>COST = N_page <span class="keyword">*</span> a_tuple_IO_time + N_tuple <span class="keyword">*</span> a_tuple_CPU_time
</code></pre><h1 id="索引扫描代价估算公式">索引扫描代价估算公式</h1>
<pre><code><span class="constant">COST</span> = C_index + N_page_index * a_tuple_IO_time
<span class="constant">C_index：索引的IO花费。C_index</span> = N_page_index * a_page_IO_time
<span class="constant">N_page_index：索引作用下的可用元组数。N_page_index</span> = N_tuple * 索引选择率
</code></pre><h1 id="索引">索引</h1>
<pre><code>本质上是通过索引直接定位表的物理元组，加快数据获取的方式，所以索引优化的手段是物理查询优化。
</code></pre><h1 id="如何利用索引">如何利用索引</h1>
<pre><code><span class="number">1</span>）索引列作为条件出现在 <span class="keyword">WHERE</span>，HAVING， <span class="keyword">ON</span> 子句中。

<span class="number">2</span>）索引列是被连接的表（内表）对象的列且存在于连接条件中

除了上述两种情况，还有一些特殊情况可以使用索引，如：排序操作、在索引列上求<span class="keyword">MIN</span>、<span class="keyword">MAX</span>值等。
</code></pre><p>（1）对表做查询，没有列对应作为过滤条件（如出现在WHERE子句中），只能做顺序扫描。</p>
<p>（2）对表做查询，有列对象且索引列作为过滤条件，可做索引扫描。</p>
<p>（3）对表做查询，有列对象作为过滤条件，但索引列被运算符“-”处理，查询优化器不能在执行前进行取反运算，这时不可利用索引扫描，只能做顺序扫描。</p>
<p>（4）对表做查询，有列对象作为过滤条件，且目标列没有超出索引列，可做只读索引扫描，这种扫描方式比单纯的索引扫描的效率更高。</p>
<p>（5）对表做查询，有索引存在，但选择条件不包括索引列对象，只能使用顺序扫描。</p>
<p>（6）对表做查询，有索引存在，选择条件包括索引列对象，可使用索引扫描，对选择条件中不存在索引的列作为过滤器被使用。</p>
<p>（7）对表做查询，有索引存在，选择条件包括索引列对象，但索引列对象位于一个表达式中，参与了运算，不是“key=常量”格式，则索引不可使用，只能是顺序扫描。如：<br>    select a.<em> from a where a.a1 + a.a3 = 2；（a1列是索引），这时只能做顺序扫描。<br>    或<br>    select a.</em> from a where a.a1 = 2 - a.a3 ；（a1列是索引），这时只能做顺序扫描。</p>
<p>（8）对表做查询，有索引列对象作为过滤条件，操作符是范围操作符 &gt; 或 &lt; ，可做索引扫描。</p>
<p>（9）对表做查询，有索引列对象作为过滤条件，操作符是范围操作符 &lt;&gt; ，不可做索引扫描。</p>
<p>（10）对表做查询，有索引列对象作为过滤条件，操作符是范围操作符BETWEEN-AND ，可做索引扫描。</p>
<h1 id="索引列的位置对使用索引的影响">索引列的位置对使用索引的影响</h1>
<pre><code>（<span class="number">1</span>）索引列出现在目标列，通常不可使用索引（但不是全部情况下不能使用索引）

（<span class="number">2</span>）聚集函数<span class="keyword">MIN</span> <span class="subst">/</span> <span class="keyword">MAX</span>用在索引列上，出现在目标列，可使用索引。

（<span class="number">3</span>）索引列出现在<span class="keyword">WHERE</span>子句中，可使用索引。

（<span class="number">4</span>）索引列出现在 <span class="keyword">JOIN</span> <span class="subst">/</span> <span class="keyword">ON</span> 子句中，作为连接条件，有时不可使用索引。（这取决于代价估算模型）

（<span class="number">5</span>）索引列出现在 <span class="keyword">JOIN</span> <span class="subst">/</span> <span class="keyword">ON</span> 子句中，作为限制条件满足“key <span class="subst">&lt;</span>op<span class="subst">&gt;</span> 常量 ”格式可用索引。

（<span class="number">6</span>）（<span class="number">5</span>）索引列出现在 <span class="keyword">WHERE</span>子句中，但与子查询比较，格式上不满足<span class="string">"key &lt;op&gt; 常量"</span>，不可用索引。
</code></pre><h1 id="索引列对GROUP_BY子句的影响">索引列对GROUP BY子句的影响</h1>
<pre><code>（<span class="number">1</span>）索引列出现在 <span class="keyword">group</span> <span class="keyword">by</span> 子句中，不触发索引扫描。

（<span class="number">2</span>）<span class="keyword">WHERE</span>子句出现索引列，【且】<span class="keyword">GROUP</span> <span class="keyword">BY</span> 子句出现索引列，索引扫描被使用。

（<span class="number">3</span>）<span class="keyword">WHERE</span>子句中出现非索引列，且<span class="keyword">GROUP</span> <span class="keyword">BY</span>子句出现索引列，索引扫描不被使用。
</code></pre><h1 id="索引列对HAVING子句的影响">索引列对HAVING子句的影响</h1>
<pre><code>（<span class="number">1</span>）<span class="keyword">WHERE</span>子句出现非索引列，且<span class="keyword">GROUP</span> <span class="keyword">BY</span>和HAVING子句出现索引列，索引扫描被使用。
</code></pre><h1 id="索引列对ORDER_BY子句的影响">索引列对ORDER BY子句的影响</h1>
<pre><code>（<span class="number">1</span>）<span class="keyword">ORDER</span> <span class="keyword">BY</span>子句出现索引列，可使用索引。

（<span class="number">2</span>）<span class="keyword">ORDER</span> <span class="keyword">BY</span>子句使用非索引列，不可使用索引扫描。
</code></pre><h1 id="索引列对_DISTINCT_的影响">索引列对 DISTINCT 的影响</h1>
<pre><code>（<span class="number">1</span>）<span class="keyword">DISTINCT</span> 子句管辖范围内出现索引列，不可使用索引。
</code></pre><h1 id="联合索引对索引使用的影响">联合索引对索引使用的影响</h1>
<pre><code><span class="input"><span class="prompt">（1）使用联合索引的全部索引键，可触发索引的使用。

（2）使用联合索引的前缀部分索引键。如：key_part_1 &lt;op&gt;</span> 常量。可触发索引的使用。</span>
<span class="input"><span class="prompt">
（3）使用部分索引，但不是联合索引的前缀部分，如“key_part_2 &lt;op&gt;</span> 常量<span class="string">"，不可触发索引的使用。

（4）使用索引索引的全部索引键，但索引键不是AND操作，不可触发索引的使用。</span></span>
</code></pre><h1 id="多个索引对索引使用的影响">多个索引对索引使用的影响</h1>
<pre><code>（<span class="number">1</span>）<span class="keyword">WHERE</span>子句出现两个可利用的索引，优选最简单的索引。（但这也是要根据代价估算模型来决定的）

（<span class="number">2</span>）<span class="keyword">WHERE</span>子句出现两个可利用的索引且索引键有重叠部分，优选最简单的索引。
</code></pre><h1 id="聚簇索引">聚簇索引</h1>
<blockquote>
<p>是指表的一个或多个列作为索引的关键字，以关键字的具体值为依据，把所有具有相同值的元组连续放在外存上。当从磁盘扫描读取的块进入内存时，相同值的其他元组在内存中的概率增大，能有效减少IO。即：聚簇索引确定表中数据的物理顺序。聚簇索引对于那些经常要搜索范围值的列特别有效。使用聚簇索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/03/《数据库查询优化器的艺术》第三章物理查询优化学习笔记/" data-id="gbjy48lonhaijnj2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-读书笔记/">PostgreSQL 读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《数据库查询优化器的艺术》第二章逻辑查询优化学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/03/《数据库查询优化器的艺术》第二章逻辑查询优化学习笔记/" class="article-date">
  <time datetime="2014-12-03T14:05:59.000Z" itemprop="datePublished">12月 3 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/03/《数据库查询优化器的艺术》第二章逻辑查询优化学习笔记/">《数据库查询优化器的艺术》第二章逻辑查询优化学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="主要解决的问题">主要解决的问题</h1>
<pre><code>如何找出SQL语句等价的变换形式，使得SQL执行更高效。
</code></pre><h1 id="可优化的思路">可优化的思路</h1>
<pre><code>（<span class="number">1</span>）子句局部优化。
如等价谓词重写，<span class="keyword">WHERE</span>和HAVING条件化简中的大部分情况。

（<span class="number">2</span>）子句间关联优化。
子句与子句之间关联的语义存在优化的可能，如外连接消除、连接消除、子查询优化、视图重写等。

（<span class="number">3</span>）局部与整体的优化。
协同局部与整体。如<span class="keyword">OR</span>重写并集规则需要考虑<span class="keyword">UNION</span>操作（<span class="keyword">UNION</span>是变换后的整体形式）的花费和<span class="keyword">OR</span>操作（<span class="keyword">OR</span>是局部表达式）的花费。

（<span class="number">4</span>）形式变化优化
多个子句存在嵌套，可能通过形式的变化完成优化。如：嵌套连接消除。

（<span class="number">5</span>）语义优化
根据完整性约束，SQL表达的含义等信息对语句进行语义优化

（<span class="number">6</span>）其他优化
根据一些规则对非SPJ做的其他优化，根据硬件环境进行的并行查询优化。

它们都是依据关系代数和启发式规则进行。
</code></pre><h1 id="关系模型">关系模型</h1>
<h4 id="关系数据结构">关系数据结构</h4>
<pre><code>即二维结构，二维表。即数据库中的表。
关系是一种对象
关系即是表
关系的元数据，即表结构，通常称为列或属性。
关系的数据，即表的行数据，通常称为元组（<span class="keyword">tuple</span>），也称为记录(<span class="keyword">record</span>)。        
</code></pre><h4 id="关系操作集合">关系操作集合</h4>
<pre><code>并，交，差，积，选择，投影，连接，除。。
选择：单个关系中筛选元组。
投影：单个关系中筛选列。
连接：多个关系中根据列间的逻辑运算筛选元组（自然连接，等值连接）
除：多个关系中根据条件筛选元组（<span class="keyword">NOT</span> EXISTS 的子查询实现除）
并：多个关系合并元组（用<span class="keyword">UNION</span>实现并）
交：多个关系中根据条件筛选元组（用两次<span class="keyword">NOT</span> <span class="keyword">IN</span> 实现交）
差：多个关系中根据条件筛选元组（<span class="keyword">NOT</span> <span class="keyword">IN</span> 子查询实现差）
积：无连接条件。N*M条元组
</code></pre><h4 id="关系类型">关系类型</h4>
<pre><code><span class="xml">R <span class="tag">&lt;<span class="title">op</span>&gt;</span> S

自然连接：R和S中“公共属性”，结果包括公共属性名字上相等的所有元组的组合，在结果中把重复的列去掉。（是同时从列和行的角度进行去重）

@-连接：R和S中没有公共属性，结果包括在R和S中满足操作符@的所有组合。@通常包括：<span class="tag">&lt; &lt;=<span class="value">,</span> =<span class="value">,</span> =<span class="value">,</span> &gt;</span>=。即从关系R和S的广义笛卡儿积中选取A，B属性相等的那些元组，是从“行”的角度进行运算。

等值连接：操作符是 = 的@-连接。

半连接：结果包括在S中公共属性名字上相等的元组的所有的R中的元组。即结果包括R的部分元组，而R中的部分元组的公共属性的值在S中同样存在。SQL中没有自己的连接操作符，使用EXISTS， IN 关键字做子句的子查询常被查询优化器转换为半连接。

反连接：结果是在S中没有在公共属性名字上相等的元组的R的元组。即为半连接的补集，反连接有时称为反半连接。在SQL中没有自己的连接操作符，使用了 NOT EXISTS 则被查询优化器转换为反半连接。

外连接（左外连接）：结果包括R中的所有元组。若在S中有在公共属性名字上相等的元组，则正常连接；若在S中没有公共属性名字上相等的元组，则依旧保留此元组，并将对应的其他列设为NULL

外连接（右外连接）：结果包括S中的所有元组。若在R中有在公共属性名字上相等的元组，则正常连接；若在R中没有公共属性名字上相等的元组，则依旧保留此元组，并将对应的其他列设为NULL

外连接（全外连接）：结果包括S和R中的所有元组。对于每个元组，若在另一个关系中有在公共属性名字上相等的元组，则正常连接；若在另一人关系中没有公共属性名字上相等的元组，则依旧保留此元组，并将对应的其他列设为NULL</span>
</code></pre><h4 id="关系完整性约束">关系完整性约束</h4>
<h1 id="查询句与二叉树">查询句与二叉树</h1>
<pre><code>叶子是关系（表）

内部结点是运算符（或称算子，操作符，如 <span class="built_in">LEFT</span> OUT <span class="built_in">JOIN</span>，表示左右子树的运算方式）

子树是子表达式或SQL片段

根结点是最后运算符的操作符

根结点运算后，得到的是SQL查询优化后的结果

这样一棵树就是一个查询的路径

多个关系连接，连接顺序不同，可以得出多个类似的二叉树

查询优化就是找出代价最小的二叉树，即最优的查询路径。

基于代价估算的查询优化就是通过计算和比较，找出花费最少的是优二叉树。
</code></pre><h1 id="从运算符的角度考虑优化">从运算符的角度考虑优化</h1>
<pre><code>不同的运算符优化可<span class="built_in">c</span>减少中间生成物的大小和数量，节约<span class="type">IO</span>和内存<span class="type">CPU</span>等，从而提高执行速度。前提是优化前和优化后是等价的。
</code></pre><h4 id="选择_——_基本选择性质">选择 —— 基本选择性质</h4>
<pre><code>对同一个表的同样选择条件，作一次即可。
可优化的原因：
幂等性：多次应用同一个选择有同样的效果
交换性：应用选择的次序在最终结果中没有影响
选择可有效减少在它的操作数中的元组数的运算（元组数减少）
</code></pre><h4 id="选择_——_分解有复杂条件的选择">选择 —— 分解有复杂条件的选择</h4>
<pre><code>合取：合并多个选择为更少的需求值的选择，多个等式可以合并。它等价于针对这些单独的一系列选择。
析取：分解它们使得其成员选择可被移动或单独优化。它等价于选择的并集。
</code></pre><h4 id="选择_——_和叉积">选择 —— 和叉积</h4>
<pre><code>尽可能选做选择：关系有<span class="keyword">N</span>和M行，先做积运算将包含<span class="keyword">N</span>*M行。先做选择运算，减少<span class="keyword">N</span>和M，则可避免不满足条件的条件参与积的运算，节约时间减少结果的大小。

尽可能下推选择：如果积不跟随着选择运算，可尝试使用其他规则从表达式树更高层下推选择。
</code></pre><h4 id="选择_——_和集合运算">选择 —— 和集合运算</h4>
<pre><code>选择下推到的集合运算中：选择在差集，交集和并集算子上满足分配律。
</code></pre><h4 id="选择_——_和投影">选择 —— 和投影</h4>
<pre><code>在投影之前进行选择：如果选择条件中引用的字段是投影中的字段的子集，则选择与投影满足交换性。
</code></pre><h4 id="投影_——_和基本投影性质">投影 —— 和基本投影性质</h4>
<pre><code>尽可能先做投影：投影是幂等性的；投影可以减少元组大小。
</code></pre><h4 id="投影_——_和集合运算。">投影 —— 和集合运算。</h4>
<pre><code>投影下推到集合运算中：投影在差集，交集和并集运算上满足分配律。
</code></pre><h1 id="运算规则主导的优化">运算规则主导的优化</h1>
<h4 id="连接、笛卡儿积_交换律">连接、笛卡儿积 交换律</h4>
<pre><code>做连接、做积运算，可交换前后位置，其结果不变。如两表连接算法中嵌套连接算法，对外表和内表有要求，外表尽可能小则有利于做“基于块的嵌套循环连接“，所以，通过交换律可以把元组少的表作为外表。
</code></pre><h4 id="连接、笛卡儿积_结合律">连接、笛卡儿积 结合律</h4>
<pre><code>做连接、做积运算，如果新的结合有利于减少中间关系的大小，则可优先处理。
</code></pre><h4 id="投影的串接定律">投影的串接定律</h4>
<pre><code>在同一个关系上，只需要做一次投影运算，且一次投影时选择多列同时完成。所以许多数据库优化引擎为同一个关系收集齐本关系上的所有列（目标列和 <span class="keyword">WHERE</span>， <span class="keyword">GROUP</span> <span class="keyword">BY</span> 等子句的本关系的列）
</code></pre><h4 id="选择的串接定律">选择的串接定律</h4>
<pre><code>选择条件可以合并，使得可一次就检查全部条件，不必多次过滤元组，所以可以把同层的合取条件收集在一起，统一判断。
</code></pre><h4 id="选择与投影的交换律">选择与投影的交换律</h4>
<pre><code>（1）先投影后选择，可以改为先选择后投影，这对于以行为存储格式的主流数据库而言，很有优化意义。存储方式总是在先获得元组后才能解析得到其中的列。

（2）先择选后投影，可以改为带有选择条件中列的投影后再选择，最后完成最外层的投影，这样，使得内层的选择和投影可以同时进行。
</code></pre><h4 id="选择与笛卡儿积的分配律">选择与笛卡儿积的分配律</h4>
<pre><code>条件下推到相关的关系上，先做选择后做积运算，这样可以减小中间结果的大小。
</code></pre><h4 id="选择与并的分配律">选择与并的分配律</h4>
<pre><code>条件下推到相关的关系上，先做选择后做并运算，可以减小每个关系输出结果的大小。
</code></pre><h4 id="选择与差的分配律">选择与差的分配律</h4>
<pre><code>条件下推到相关的关系上，先做选择后做差运算，可以减小每个关系输出结果的大小。
</code></pre><h4 id="投影与笛卡儿积的分配律">投影与笛卡儿积的分配律</h4>
<pre><code>先做投影后做积，可减少做积前每个元组的长度，使得再做积后得到新元组的长度变短。
</code></pre><h4 id="投影与并的分配律">投影与并的分配律</h4>
<pre><code>先做投影后做并，可减少做并前每个元组的长度。
</code></pre><h1 id="OLTP">OLTP</h1>
<pre><code>On-<span class="built_in">line</span> Transaction Processing, OLTP。
</code></pre><h1 id="SPJ">SPJ</h1>
<pre><code><span class="operator"><span class="keyword">SELECT</span>， 投影（PROJECT）， 连接（<span class="keyword">JOIN</span>）</span>
</code></pre><h1 id="查询优化对SPJ的优化方式如下：">查询优化对SPJ的优化方式如下：</h1>
<pre><code><span class="number">1</span>）选择操作。对应的是限制条件（格式类似 field&lt;op&gt;consant）优化方式是选择操作下推，目的是尽量减少连接操作前的元组数，使得中间临时关系尽量少。这可减少IO和CPU等的消耗。

<span class="number">2</span>）投影操作：对应<span class="keyword">SELECT</span>查询的目的的列对象。优化方式是投影操作下推。目的是尽量减少连接操作前的列数，使得中间临时关系尽量小（选择操作是使元组个数”尽量少“，投影操作，是使一条元组”尽量小“）。这样，虽然不能减少IO（多数数据库存储方式是行存储，元组是读取的最基本单位，所以想要操作列必须读取一行数据）。但可以减少连接后的中间关系的元组大小，节约内存。

<span class="number">3</span>）连接操作：对应的是连接条件。（格式为field1&lt;op&gt;field2, field1和field表示”不同表“上的列对象。表示两个表连接条件。（<span class="number">1</span>）”多表连接中每个表被连接的顺序决定着效率。“，即如果ABC三个表，ABC， ACB， CBA， BCA等不同的连接后结果一样的话，则要计算哪种效率最高。（<span class="number">2</span>）多表连接每个表被连接的顺序由用户语义决定，这决定着表之间的前后连接次序是不能随意更换的。

<span class="number">4</span>）非SPJ（在SPJ的基础上存在 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 操作的查询，这是一种复杂的查询）。
</code></pre><h1 id="子查询优化">子查询优化</h1>
<pre><code>它是一种比较耗时的操作，优化子查询对查询效率的提升有着直接的影响。
</code></pre><h4 id="子查询可出现的位置及对优化的影响">子查询可出现的位置及对优化的影响</h4>
<pre><code><span class="number">1</span>）目标列
这时，只能是标量子查询，否则数据库可能返回类似”错误：子查询必须只能返回一个字段“的提示。

<span class="number">2</span>）<span class="keyword">FROM</span>子句
相关子查询不能出现在<span class="keyword">FROM</span>子句中；非相关子查询出现在<span class="keyword">FROM</span>子句中，可上拉子查询到父层，在多表连接时统一考虑连接代价后择优。

<span class="number">3</span>）<span class="keyword">WHERE</span>子句

<span class="number">4</span>）<span class="keyword">JOIN</span>/<span class="keyword">ON</span>子句
它们处理方式同<span class="keyword">FROM</span>子句和<span class="keyword">WHERE</span>子句

<span class="number">5</span>）<span class="keyword">GROUP</span> <span class="keyword">BY</span>子句
目标列必须和 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 关联。可将子查询写在<span class="keyword">GROUP</span> <span class="keyword">BY</span>位置，但没有什么实用意义。

<span class="number">6</span>）HAVING子句

<span class="number">7</span>）<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句
</code></pre><h1 id="子查询优化技术">子查询优化技术</h1>
<pre><code>1）子查询合并
等价的情况下。多个子查询能够合并成一个子查询。这样可以把多次表扫描，多次连接减少为单次表扫描和单次连接。如：

<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> a1 &lt; <span class="number">10</span> <span class="keyword">and</span> (<span class="keyword">exists</span> (<span class="keyword">select</span> a2 <span class="keyword">from</span> t2 <span class="keyword">where</span> t2.a2 &lt; <span class="number">5</span> <span class="keyword">and</span> t2.b2 = <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">exists</span> (<span class="keyword">select</span> a2 <span class="keyword">from</span> t2 <span class="keyword">where</span> t2.a2 &lt; <span class="number">5</span> <span class="keyword">and</span> t2.b2 = <span class="number">2</span>)

可优化为

<span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> a1 &lt; <span class="number">10</span> <span class="keyword">and</span> ( <span class="keyword">exists</span> (<span class="keyword">select</span> a2 <span class="keyword">from</span> t2 <span class="keyword">where</span> t2.a2 &lt; <span class="number">5</span> <span class="keyword">and</span> ( t2.b2 = <span class="number">1</span> <span class="keyword">or</span> t2.b2 = <span class="number">2</span>));</span>

2）子查询展开
又称子查询反嵌套，又称为子查询上拉。把一些子查询置于外层的父查询中，作为连接关系与外层父查询并列。实质上是把某些子查询重写为等价的多表连接操作。如：

<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> t1, ( <span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> t2.a2 &gt; <span class="number">10</span>) v_t2 <span class="keyword">where</span> t1.a1 &lt; <span class="number">10</span> <span class="keyword">and</span> v_t2.a2 &lt; <span class="number">20</span>

可优化为

<span class="keyword">select</span> * <span class="keyword">from</span> t1, t2 <span class="keyword">where</span> t1.a1 &lt; <span class="number">10</span> <span class="keyword">and</span> t2.a2 &lt; <span class="number">20</span> <span class="keyword">and</span> t2.a2 &gt; <span class="number">10</span>

<span class="number">3</span>）聚集子查询消除
将聚集函数上推，将子查询转变为一个新的不包含聚集函数的子查询，并与父查询的部分或者全部表做左外连接。

<span class="number">4</span>）其他
利用窗口函数消除子查询的技术。子查询推进等技术</span>
</code></pre><h1 id="子查询展开">子查询展开</h1>
<pre><code><span class="number">1</span>）如果子查询出现了聚集、<span class="keyword">GROUP</span> <span class="keyword">BY</span>， <span class="keyword">DISTINCT</span> 子句，则子查询只能单独求解，不可以上拉到上层。

<span class="number">2</span>）如果子查询只是一个简单格式（SPJ）的查询语句，则可以上拉到上层，这样往往能提高查询效率。
</code></pre><h4 id="子查询展开的规则">子查询展开的规则</h4>
<pre><code>1）如果上层查询的结果没有重复（即<span class="operator"><span class="keyword">SELECT</span>子句中包含主键），则可以展开其子查询，并且展开后的查询的<span class="keyword">SELECT</span> 子句前就回上 <span class="keyword">DISTINCT</span> 标志。

<span class="number">2</span>）如果上层有 <span class="keyword">DISTINCT</span> 标志，则可以直接展开子查询

<span class="number">3</span>）如果内层查询结果没有重复元组，则可以展开。</span>
</code></pre><h4 id="子查询展开的步骤">子查询展开的步骤</h4>
<pre><code><span class="number">1</span>）将子查询和上层查询的<span class="keyword">FROM</span>子句连接，为同一个<span class="keyword">FROM</span>子句，并修改相应的运行参数

<span class="number">2</span>）将子查询的谓词符号进行相应修改。如 <span class="keyword">IN</span>修改为=ANY

<span class="number">3</span>）将子查询的<span class="keyword">WHERE</span>条件作为一个整体与上层查询的<span class="keyword">WHERE</span>条件合并，并用<span class="keyword">AND</span>条件连接词连接。
</code></pre><h1 id="子查询优化说明">子查询优化说明</h1>
<pre><code>子查询类似： <span class="number">10</span> IN (select <span class="keyword">...</span>）这不能做上拉操作，所以不能优化
子查询类似：出现 random()等易失函数，子查询结果不能确定，所以查询优化器就不能对子查询优化。
</code></pre><h1 id="ALL/SOME/ANY类型">ALL/SOME/ANY类型</h1>
<pre><code>如果子查询没有 GROUP BY 子句，也没有聚集函数。则可以使用如下表达式做等价转换：

val &gt; ALL (select <span class="keyword">...</span>) 等价为 val &gt; MAX(select <span class="keyword">...</span>)

val &lt; ALL (select <span class="keyword">...</span>) 等价为 val &lt; min( select <span class="keyword">...</span>)

val &gt; any (select <span class="keyword">...</span>) 等价为 val &gt; min(select ....）

val &lt; any (select <span class="keyword">...</span>) 等价为 val&lt;max(select ....)

val &gt;= ALL 同上
val &lt;= ALL
val &gt;= ANY
val &lt;= ANY
</code></pre><h1 id="视图重写">视图重写</h1>
<pre><code>就是将视图的引用重写为对基本表的引用。如：
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> t_a ( a <span class="built_in">int</span> , b <span class="built_in">int</span> );</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">view</span> v_a <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_a;</span>

基于视图的命令：
<span class="operator"><span class="keyword">select</span> col_a <span class="keyword">from</span> v_a <span class="keyword">where</span> col_b &gt; <span class="number">100</span>;</span>
经过视图重写后：
<span class="operator"><span class="keyword">select</span> col_a <span class="keyword">from</span> ( <span class="keyword">select</span> col_a , col_b <span class="keyword">from</span> t_a) <span class="keyword">where</span> col_b &gt; <span class="number">100</span>;</span>
再经过优化后，则是：
<span class="operator"><span class="keyword">select</span> col_a <span class="keyword">from</span> t_a <span class="keyword">where</span> col_b &gt; <span class="number">100</span>;</span>

简单的视图（SPJ）可以被查询优化器较好地处理。
但复杂视图则不能被查询优化器很好地处理。
</code></pre><h1 id="等价谓词重写">等价谓词重写</h1>
<pre><code><span class="number">1</span>）LIKE规则
如：name like <span class="string">'abc%'</span>
重写为
name <span class="subst">&gt;=</span> <span class="string">'abc'</span> <span class="literal">and</span> name <span class="subst">&lt;</span> <span class="string">'abd'</span>;
应用like规则的好处：转换前针对 like 谓词只能进行全表扫描。如果name列上存在索引，则转换后可以进行索引范围扫描。

如果没有通配符（<span class="subst">%</span>或_）。则是与 <span class="subst">=</span> 等价
name like <span class="string">'abc'</span>
重写为
name <span class="subst">=</span> <span class="string">'abc'</span>

<span class="number">2</span>） BETWEEN<span class="attribute">-AND</span>规则
sno BETWEEN <span class="number">10</span> <span class="literal">AND</span> <span class="number">20</span> 
重写为
sno <span class="subst">&gt;=</span> <span class="number">10</span> <span class="literal">and</span> sno <span class="subst">&lt;=</span><span class="number">20</span>
好处：如果sno建立了索引，则可以用索引扫描代替原来的BETWEEN<span class="attribute">-AND</span>谓词限定的全表扫描，从而提高了查询的效率。

<span class="number">3</span>）<span class="keyword">IN</span>转换<span class="literal">OR</span>规则
<span class="keyword">IN</span>只是<span class="keyword">IN</span>操作符，而不是<span class="keyword">IN</span>子查询。改为<span class="literal">OR</span>可以更好地利用索引进行优化。将<span class="keyword">IN</span>改为若干个<span class="literal">OR</span>可能会提高效率。
age <span class="keyword">IN</span> （<span class="number">8</span>, <span class="number">12</span>, <span class="number">21</span>）
重写为
age <span class="subst">=</span> <span class="number">8</span> <span class="literal">or</span> age <span class="subst">=</span> <span class="number">12</span> <span class="literal">or</span> age <span class="subst">=</span> <span class="number">21</span>
效率是否提高，需要看数据库对<span class="keyword">IN</span>谓词是否只支持全表扫描。如果数据库对<span class="keyword">IN</span>谓词只支持全表扫描且<span class="literal">OR</span>谓词中表的age列存在索引，则转换后的查询效率会更好。

<span class="number">4</span>）<span class="keyword">IN</span>转换ANY规则
因为<span class="keyword">IN</span>可以转换为<span class="literal">OR</span>，而<span class="literal">OR</span>可转换为ANY，所以可以直接把<span class="keyword">IN</span>转换为ANY。这可能会提高效率。
age <span class="keyword">IN</span> (<span class="number">8</span>, <span class="number">12</span>, <span class="number">21</span>)
重写为
age any (<span class="number">8</span>, <span class="number">12</span>, <span class="number">21</span>)
效率是否提高，依赖于数据库对ANY操作的支持情况。
如：PostgreSQL没有显式支持 ANY 操作，但在内部实现时把<span class="keyword">IN</span>操作转换为了ANY操作。（通过 explain 知道）


<span class="number">5</span>）<span class="literal">OR</span>转换为ANY规则
这样可以更好地利用 <span class="keyword">MIN</span>/<span class="keyword">MAX</span> 操作进行优化。但（PG9<span class="number">.2</span><span class="number">.3</span> 和 MySQL <span class="number">5.6</span><span class="number">.10</span> 目前都还没有支持）

<span class="number">6</span>）<span class="literal">ALL</span>/ANT 转换为集函数规则
这样可以更好地利用 <span class="keyword">MIN</span>/<span class="keyword">MAX</span> 操作进行优化。如：
sno <span class="subst">&gt;</span> ANY (<span class="number">10</span>, <span class="number">2</span><span class="subst">*</span><span class="number">5</span><span class="subst">+</span><span class="number">3</span>, sqrt(<span class="number">9</span>))
重写为
sno <span class="subst">&gt;</span> sqrt(<span class="number">9</span>)
通常，聚集函数<span class="keyword">MAX</span>(), <span class="keyword">MIN</span>()等的效率比ANY， <span class="literal">ALL</span>谓词的执行效率高。

<span class="number">7</span>）<span class="literal">NOT</span>规则
<span class="literal">NOT</span> (col_1 <span class="subst">!=</span> <span class="number">2</span>) 重写为 col_1 <span class="subst">=</span> <span class="number">2</span> 其他类似
好处：如果 col_1 上建立了索引，则可以用索引扫描代替原来的全表扫描。

<span class="number">8</span>）<span class="literal">OR</span>重写并集规则
如：
<span class="keyword">select</span> <span class="subst">*</span> from student <span class="keyword">where</span> ( sex <span class="subst">=</span> <span class="string">'f'</span> <span class="literal">and</span> sno <span class="subst">&gt;</span> <span class="number">15</span> ) <span class="literal">or</span> age <span class="subst">&gt;</span> <span class="number">18</span>；
这条SQL会强迫查询优化器使用顺序存取，因为这个语句要检索的是<span class="literal">OR</span>操作的集合。假设，sex, age 上有索引，则可优化为：
<span class="keyword">select</span> <span class="subst">*</span> from student <span class="keyword">where</span> sex <span class="subst">=</span> <span class="string">'f'</span> <span class="literal">and</span> sno <span class="subst">&gt;</span> <span class="number">15</span> union <span class="keyword">select</span> <span class="subst">*</span> from student <span class="keyword">where</span> age <span class="subst">&gt;</span> <span class="number">18</span>；
</code></pre><h1 id="条件简化">条件简化</h1>
<pre><code><span class="number">1</span>）把HAVING条件并入WHERE条件。（只有SQL语句不存在 GROUP BY 条件 或聚集函数的情况下才可以使用）

<span class="number">2</span>）去除表达式中冗余的括号。这样子可以减少语法分析时产生的AND和OR树的层次。

<span class="number">3</span>）常量传递。如：<span class="variable">col_1 =</span> col_2 <span class="constant">and</span> <span class="variable">col_2 =</span> <span class="number">3</span> 。改为：<span class="variable">col_1 =</span> <span class="number">3</span> <span class="constant">and</span> <span class="variable">col_2 =</span> <span class="number">3</span>;

<span class="number">4</span>）消除死码。如：永恒为假的条件。

<span class="number">5</span>）表达式计算：如：where <span class="variable">col_1 =</span> <span class="number">1</span> + <span class="number">2</span> ，改为 where <span class="variable">col_1 =</span> <span class="number">3</span>

<span class="number">6</span>）等式变换：化简条件（如反转关系操作符的操作数顺序）。如： <span class="variable">-a =</span> <span class="number">3</span>; 简化为 <span class="variable">a =</span> -<span class="number">3</span>；

<span class="number">7</span>）不等式变换。化简条件。如：a &gt; <span class="number">10</span> <span class="constant">and</span> <span class="variable">b =</span> <span class="number">6</span> <span class="constant">and</span> a &gt; <span class="number">2</span> ，简化为 <span class="variable">b =</span> <span class="number">6</span> <span class="constant">and</span> a &gt; <span class="number">10</span>

<span class="number">8</span>）布尔表达式变换。

<span class="number">9</span>）谓词传递闭包。

<span class="number">10</span>）任何一个布尔表达式都能被转换为一个等价的合取范式（CNF）。如：<span class="constant">and</span> 操作符是可交换的，所以优化器可以按先易后难的顺序计算表达式。

<span class="number">11</span>）索引的利用。
</code></pre><h1 id="外连接消除">外连接消除</h1>
<pre><code>外连接的左右子树不能互换。
查询重写的一项技术就是把外连接，转换为内连接。意义：
1）查询优化器在处理外连接操作时所需要的时间多于内连接

2）优化器在选择表连接顺序时，可以有更多更灵活的选择，从而sk以选择更好的表连接顺序。

3）表的一些连接算法，将规模小的或筛选严格的条件的作为外表，可以减少不必要的IO开销，极大地加快算法执行的速度。
</code></pre><h1 id="嵌套连接消除">嵌套连接消除</h1>
<pre><code>嵌套连接是指：当执行连接操作的次序不是从左到右逐个进行时，就说明这样的连接表达式存在嵌套。

<span class="number">1</span>）如果连接表达式只包括内连接（<span class="keyword">JOIN</span> <span class="keyword">ON</span>），括号可以去掉，这意味着表之间的次序可以交换。

<span class="number">2</span>）如果连接表达式包括外连接，括号不可以去掉，意味着表之间的次序只能按原语义进行，至多能执行的就是外连接向内连接转换。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/03/《数据库查询优化器的艺术》第二章逻辑查询优化学习笔记/" data-id="gvuyccdgryiikxef" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-读书笔记/">PostgreSQL 读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-自行测试的1亿条数据中PostgreSQL性能" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/02/自行测试的1亿条数据中PostgreSQL性能/" class="article-date">
  <time datetime="2014-12-02T11:16:31.000Z" itemprop="datePublished">12月 2 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/02/自行测试的1亿条数据中PostgreSQL性能/">自行测试的1亿条数据中PostgreSQL性能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="插入一亿条数据">插入一亿条数据</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test=# <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_time1 <span class="keyword">select</span> generate_series(<span class="number">1</span>,<span class="number">100000000</span>),clock_timestamp(),<span class="keyword">now</span>();</span></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">100000000</span></span></div><div class="line"><span class="keyword">Time</span>: <span class="number">525833.218</span> ms</div><div class="line"></div><div class="line">约:<span class="number">8.7</span>分钟</div></pre></td></tr></table></figure>

<h1 id="COUNT，没有索引，1亿条数据。">COUNT，没有索引，1亿条数据。</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">test=# select count(1) from tbl<span class="emphasis">_time1;</span></div><div class="line"></div><div class="line"><span class="header">   count   </span></div><div class="line">-----------</div><div class="line"><span class="code"> 100000000</span></div><div class="line">(1 row)</div><div class="line"></div><div class="line">Time: 3070658.058 ms</div><div class="line">约:51.2分钟</div></pre></td></tr></table></figure>

<h1 id="添加主键索引耗时">添加主键索引耗时</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test=# <span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_time1 <span class="keyword">add</span> <span class="keyword">primary</span> <span class="keyword">key</span> (id);</span></div><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span></div><div class="line"><span class="keyword">Time</span>: <span class="number">981276.804</span> ms</div><div class="line"></div><div class="line">约：<span class="number">16.4</span>分钟</div></pre></td></tr></table></figure>

<p>再 explain 一下看看</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">test=</span><span class="comment"># explain select count(id) from tbl_time1;</span></div><div class="line">                                 QUERY PLAN                                 </div><div class="line">-----------------------------------------------------------------------------</div><div class="line"> Aggregate  (<span class="variable">cost=</span><span class="number">7770150.00</span>..<span class="number">7770150.01</span> <span class="variable">rows=</span><span class="number">1</span> <span class="variable">width=</span><span class="number">4</span>)</div><div class="line">   -&gt;  Seq Scan on tbl_time1  (<span class="variable">cost=</span><span class="number">0.00</span>..<span class="number">7520150.00</span> <span class="variable">rows=</span><span class="number">100000000</span> <span class="variable">width=</span><span class="number">4</span>)</div><div class="line">(<span class="number">2</span> rows)</div></pre></td></tr></table></figure>

<p>虽然 id 上有索引，但是依然是使用顺序扫描。</p>
<h1 id="COUNT，有索引(主键），1亿条数据，还要注意有没有_where_id_&gt;_0_的条件的差别">COUNT，有索引(主键），1亿条数据，还要注意有没有 where id &gt; 0 的条件的差别</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">这个有 where id &gt; <span class="number">0</span></div><div class="line"><span class="variable">test=</span><span class="comment">#  select count(id) from tbl_time1 where id &gt; 0;</span></div><div class="line">   count   </div><div class="line">-----------</div><div class="line"> <span class="number">100000000</span></div><div class="line">(<span class="number">1</span> row)</div><div class="line"></div><div class="line">Time: <span class="number">244243.112</span> ms</div><div class="line">约：<span class="number">4.071</span>分钟</div><div class="line"></div><div class="line"><span class="variable">test=</span><span class="comment"># explain select count(id) from tbl_time1 where id &gt; 0;</span></div><div class="line">                                          QUERY PLAN                                          </div><div class="line">-----------------------------------------------------------------------------------------------</div><div class="line"> Aggregate  (<span class="variable">cost=</span><span class="number">7644075.89</span>..<span class="number">7644075.90</span> <span class="variable">rows=</span><span class="number">1</span> <span class="variable">width=</span><span class="number">4</span>)</div><div class="line">   -&gt;  Bitmap Heap Scan on tbl_time1  (<span class="variable">cost=</span><span class="number">623925.90</span>..<span class="number">7560742.56</span> <span class="variable">rows=</span><span class="number">33333333</span> <span class="variable">width=</span><span class="number">4</span>)</div><div class="line">         Recheck Cond: (id &gt; <span class="number">0</span>)</div><div class="line">         -&gt;  Bitmap Index Scan on tbl_time1_pkey  (<span class="variable">cost=</span><span class="number">0.00</span>..<span class="number">615592.57</span> <span class="variable">rows=</span><span class="number">33333333</span> <span class="variable">width=</span><span class="number">0</span>)</div><div class="line">               Index Cond: (id &gt; <span class="number">0</span>)</div><div class="line">(<span class="number">5</span> rows)</div><div class="line"> </div><div class="line">Time: <span class="number">0.767</span> ms</div><div class="line"></div><div class="line"></div><div class="line">这个无 where id &gt; <span class="number">0</span></div><div class="line"><span class="variable">test=</span><span class="comment">#  select count(id) from tbl_time1;</span></div><div class="line">   count   </div><div class="line">-----------</div><div class="line"> <span class="number">100000000</span></div><div class="line">(<span class="number">1</span> row)</div><div class="line"></div><div class="line">Time: <span class="number">548650.606</span> ms</div><div class="line">约：<span class="number">9.144</span>分钟</div><div class="line"></div><div class="line"><span class="variable">test=</span><span class="comment"># explain select count(id) from tbl_time1;</span></div><div class="line">                                 QUERY PLAN                                 </div><div class="line">-----------------------------------------------------------------------------</div><div class="line"> Aggregate  (<span class="variable">cost=</span><span class="number">7770150.00</span>..<span class="number">7770150.01</span> <span class="variable">rows=</span><span class="number">1</span> <span class="variable">width=</span><span class="number">4</span>)</div><div class="line">   -&gt;  Seq Scan on tbl_time1  (<span class="variable">cost=</span><span class="number">0.00</span>..<span class="number">7520150.00</span> <span class="variable">rows=</span><span class="number">100000000</span> <span class="variable">width=</span><span class="number">4</span>)</div><div class="line">(<span class="number">2</span> rows)</div><div class="line"> </div><div class="line">Time: <span class="number">1.253</span> ms</div></pre></td></tr></table></figure>

<h1 id="COUNT_结论：（9-3-5的版本，默认配置）">COUNT 结论：（9.3.5的版本，默认配置）</h1>
<pre><code>无论你的数据有没有索引，COUNT都只会进行全表扫描。（条件是没有<span class="keyword">where</span>， 或有<span class="keyword">where</span>，但经过查询计划估算代价时，还是决定使用顺序全表扫描）。比如在上面的表，<span class="property">id</span> 有索引。大概原因是说：因为MVCC的影响。

select <span class="command">count</span>(<span class="property">id</span>) <span class="keyword">from</span> tbl_time1 <span class="keyword">where</span> <span class="property">id</span> &gt; <span class="number">0</span>;
经过PG的查询优化器估算时，它最后还是决定使用 Seq Scan 扫描。
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="variable">test=</span><span class="comment"># explain select count(id) from tbl_time2 where id &gt; 0;</span></div><div class="line">                               QUERY PLAN                               </div><div class="line">-------------------------------------------------------------------------</div><div class="line"> Aggregate  (<span class="variable">cost=</span><span class="number">21370.00</span>..<span class="number">21370.01</span> <span class="variable">rows=</span><span class="number">1</span> <span class="variable">width=</span><span class="number">4</span>)</div><div class="line">   -&gt;  Seq Scan on tbl_time2  (<span class="variable">cost=</span><span class="number">0.00</span>..<span class="number">18870.00</span> <span class="variable">rows=</span><span class="number">1000000</span> <span class="variable">width=</span><span class="number">4</span>)</div><div class="line">         Filter: (id &gt; <span class="number">0</span>)</div><div class="line">(<span class="number">3</span> rows)</div><div class="line"> </div><div class="line">Time: <span class="number">0.872</span> ms</div></pre></td></tr></table></figure>

<pre><code>Postgres中通过需要扫描来计数<span class="built_in">count</span>(*)的成本比较高. 没有别的办法来来对行数计数并返回结果除了扫描全部数据.
</code></pre><h1 id="通过修改配置文件调优，时间从_：51-2分钟—&gt;9-144分钟—&gt;4-071分钟—&gt;1-456分钟">通过修改配置文件调优，时间从 ：51.2分钟—&gt;9.144分钟—&gt;4.071分钟—&gt;1.456分钟</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">enable_bitmapscan = off</div><div class="line">enable_hashagg = <span class="command"><span class="keyword">on</span></span></div><div class="line">enable_hashjoin = <span class="command"><span class="keyword">on</span></span></div><div class="line">enable_indexscan = <span class="command"><span class="keyword">on</span></span></div><div class="line">enable_indexonlyscan = <span class="command"><span class="keyword">on</span></span></div><div class="line"><span class="comment">#enable_material = on</span></div><div class="line"><span class="comment">#enable_mergejoin = on</span></div><div class="line"><span class="comment">#enable_nestloop = on</span></div><div class="line">enable_seqscan = off</div><div class="line"><span class="comment">#enable_sort = on</span></div><div class="line">enable_tidscan = off</div><div class="line">实测在如此配置的情况下，indexonlyscan优先!</div><div class="line"></div><div class="line">所谓的 IndexOnlyScan，表示只在索引取数据，不用再定位物理位置后再取数据。性能最快。</div></pre></td></tr></table></figure>

<p>通过以上的配置，重启下服务器。再执行查询计划时可以看到：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">test=# explain <span class="keyword">select</span> count(id) <span class="keyword">from</span> tbl_time1 <span class="keyword">where</span> id &gt; <span class="number">0</span>;</div><div class="line">                                                QUERY PLAN                                                </div><div class="line">----------------------------------------------------------------------------------------------------------</div><div class="line"> Aggregate  (cost=<span class="number">118803211.23</span>..<span class="number">118803211.24</span> rows=<span class="number">1</span> width=<span class="number">4</span>)</div><div class="line">   -&gt;  <span class="keyword">Index</span> Only Scan <span class="keyword">using</span> tbl_time1_pkey <span class="keyword">on</span> tbl_time1  (cost=<span class="number">0.57</span>..<span class="number">118719877.89</span> rows=<span class="number">33333333</span> width=<span class="number">4</span>)</div><div class="line">         <span class="keyword">Index</span> Cond: (id &gt; <span class="number">0</span>)</div><div class="line">(<span class="number">3</span> rows)</div><div class="line"></div><div class="line">Time: <span class="number">16.033</span> ms</div><div class="line"></div><div class="line">这时变成了：<span class="keyword">Index</span> Only Scan 了。</div><div class="line">不过耗时还是需要 </div><div class="line"></div><div class="line">test=# <span class="keyword">select</span> count(id) <span class="keyword">from</span> tbl_time1 <span class="keyword">where</span> id &gt; <span class="number">0</span>;</div><div class="line">   count  </div><div class="line">-----------</div><div class="line"><span class="number">100000000</span></div><div class="line">(<span class="number">1</span> row)</div><div class="line"> </div><div class="line">Time: <span class="number">87501.151</span> ms</div><div class="line"></div><div class="line">约：<span class="number">1.456</span>分钟</div></pre></td></tr></table></figure>


<h1 id="估算表大小">估算表大小</h1>
<pre><code><span class="operator"><span class="keyword">SELECT</span> reltuples <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname = <span class="string">'tb_name'</span>;</span>
</code></pre><h1 id="并发方式建立索引">并发方式建立索引</h1>
<pre><code>当Postgres建立你的索引的时候， 和其他数据库一样, 在建立索引的时候是会锁表的. 对于小数据量来说没什么关系， 但是通常可能是我们对一个大数据量的表加索引, 这意味着要获得性能改进应用必须收到停机一段时间. 至少那一张表会受影响. Postgres有能力在创建索引的时候不锁表, 通过使用 <span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> CONCURRENTLY , 例如:

<span class="keyword">CREATE</span> <span class="keyword">INDEX</span> CONCURRENTLY idx_salary <span class="keyword">ON</span> employees(last_name, salary);</span>
</code></pre><h1 id="当你的索引比你聪明的时候">当你的索引比你聪明的时候</h1>
<pre><code>在所有索引没有被<span class="variable">Postgres</span>使用的情况, 大多数情况下你应该相信<span class="variable">Postgres</span>, 例如当你查询的结果占所有数据的大部分时候, 它可能不使用索引，因为只扫描全表一次最简单,而不是使用索引做额外的查找.
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/02/自行测试的1亿条数据中PostgreSQL性能/" data-id="6dwwr4ucqg5fiui3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《数据库查询优化器的艺术》第一章学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/02/《数据库查询优化器的艺术》第一章学习笔记/" class="article-date">
  <time datetime="2014-12-02T11:05:02.000Z" itemprop="datePublished">12月 2 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/02/《数据库查询优化器的艺术》第一章学习笔记/">《数据库查询优化器的艺术》第一章学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据库管理系统">数据库管理系统</h1>
<pre><code>数据定义
数据操纵
数据库的运行管理
数据库的建立和维护等
</code></pre><h1 id="查询优化的目标">查询优化的目标</h1>
<pre><code>使查询优化引擎生成一个执行策略的过程，尽量使查询的总开销（IO，<span class="built_in">CPU</span>，网络传输等）达到最小。
</code></pre><h1 id="查询优化技术（广义）">查询优化技术（广义）</h1>
<pre><code>查询重用技术
查询重写规则
查询算法优化技术
并行查询优化技术
分布式查询优化技术
其他方面（如框架结构）的优化技术
</code></pre><h1 id="查询优化技术（狭义）">查询优化技术（狭义）</h1>
<pre><code>查询重写规则
查询算法优化
</code></pre><h1 id="代数优化（逻辑优化）">代数优化（逻辑优化）</h1>
<pre><code>主要依据关系代数的等价变换做一些逻辑变换。查询重写规则属于逻辑优化。
</code></pre><h1 id="非代数优化（物理优化）">非代数优化（物理优化）</h1>
<pre><code>主要根据数据读取，表连接方式，表连接顺序，排序等技术对查询进行优化。查询算法优化，属于物理优化。运用了基于代价估算的多表连接算法求解最小花费的技术。
</code></pre><h1 id="数据库调优">数据库调优</h1>
<pre><code>目标是使数据库有更高的吞吐量以及更短的响应时间。它是全局的。而查询优化技术是SQL层面的，局部的优化。
</code></pre><h1 id="查询重用">查询重用</h1>
<pre><code>指尽可能利用先前的执行结果，以达到节约查询计算全过程的时间并减少资源消耗的目的。
（1）查询结果的重用
在缓冲区分配一块缓冲块，存放该SQL语句文本和最后的结果集，当遇到同样的SQL输入时，可直接把结果返回。它节约了查询计划生成时间和查询执行过程的时间，减少了查询执行全过程的资源消耗。

（2）查询计划的重用
缓存一条查询语句的执行计划及其相应语法树结构。查询计划的重用技术减少了查询计划生成的时间和资源消耗
</code></pre><h1 id="查询重写规则">查询重写规则</h1>
<pre><code>它是一种等价转换。即对于任何相关模式的任意状态都会产生相同的结果。目标：
（<span class="number">1</span>）将查询转换为等价的，效率更高的形式。
（<span class="number">2</span>）尽量将查询重写为等价，简单且不受表顺序限制的形式，为物理查询优化阶段提供更多的选择。如：视图的重写，子查询的合并转换等。
重写的主要依据是关系代数。它是查询重写规则的理论支持。
它有<span class="number">3</span>个角度，第<span class="number">4</span>个是物理优化。
（<span class="number">1</span>）语法级
（<span class="number">2</span>）代数级
（<span class="number">3</span>）语义级
（<span class="number">4</span>）物理级：即基于代价估算模型，比较得出代价最小的，是从连接路径中选择代价最小的路径的过程。

主要思路：
<span class="number">1</span>）将过程性查询转换为描述性的查询，如视图重写
<span class="number">2</span>）将复杂的查询（嵌套子查询，外连接，嵌套连接）尽可能转换为多表连接查询
<span class="number">3</span>）将效率低的谓词转换为等价的效率高的谓词（如等价谓词重写）
<span class="number">4</span>）利用等式和不等式的性质，简化 <span class="keyword">WHERE</span>， HAVING 和 <span class="keyword">ON</span> 条件

核心是：等价转换，只有等价才能转换。
</code></pre><h1 id="查询算法优化">查询算法优化</h1>
<pre><code>查询优化即求解给定查询语句的高效执行计划的过程。

单表结点获取数据的方式有：
（1）直接通过IO获取
（2）通过索引获取数据
（3）通过索引定位数据的位置再经IO到数据块中获取数据
这是从物理存储到内存解析成逻辑字段的过程。

查询计划的策略：
（1）基于规则优化
（2）基于代价优化。
PG和MySQL采取了基于规则和代价估算的查询优化策略。
</code></pre><h1 id="多表连接优化算法">多表连接优化算法</h1>
<pre><code><span class="params">SYSTEM</span>-R算法
启发式搜索算法 
贪婪算法 
动态规划算法
遗传算法
</code></pre><h1 id="并行查询优化">并行查询优化</h1>
<pre><code>单机：找到查询的一个具有最小执行花费的执行计划
并行：寻找具有最小响应时间的查询执行计划

并行查询：
（<span class="number">1</span>）操作内并行：将同一操作，如单表扫描操作，两表连接操作，排序操作等分解成多个独立的子操作，由不同的<span class="built_in">CPU</span>同时执行。
（<span class="number">2</span>）操作间并行：一条SQL查询语句可以分解成多个子操作，由多个<span class="built_in">CPU</span>执行。
</code></pre><h1 id="分布式查询优化">分布式查询优化</h1>
<pre><code><span class="attribute">查询策略优化（主要是数据传输策略）和局部处理优化（传统的单结点数据库的查询优化技术）是查询优化的重点。

主要目标：
减少传输的次数和数据量

分布式代价估算模型
总代价 </span>=<span class="string"> IO代价 + CPU代价 + 通信代价</span>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://dreamer-yzy.github.io/2014/12/02/《数据库查询优化器的艺术》第一章学习笔记/" data-id="fmsohc3a9h6b3fkr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PostgreSQL-读书笔记/">PostgreSQL 读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/archives/2014/12/page/2/">2</a><a class="extend next" rel="next" href="/archives/2014/12/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">10</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/PostgreSQL/">PostgreSQL</a><span class="category-list-count">10</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/PostgreSQL/PostgreSQL基础学习/">PostgreSQL基础学习</a><span class="category-list-count">5</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/日志/程序员/">程序员</a><span class="category-list-count">1</span></li></ul></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTE表达式/">CTE表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL-基础学习/">PostgreSQL 基础学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL-案例/">PostgreSQL 案例</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL-翻译/">PostgreSQL 翻译</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL-读书笔记/">PostgreSQL 读书笔记</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/临时表/">临时表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CTE表达式/" style="font-size: 10.00px;">CTE表达式</a><a href="/tags/Hexo/" style="font-size: 10.00px;">Hexo</a><a href="/tags/Markdown/" style="font-size: 10.00px;">Markdown</a><a href="/tags/PostgreSQL/" style="font-size: 20.00px;">PostgreSQL</a><a href="/tags/PostgreSQL-基础学习/" style="font-size: 17.50px;">PostgreSQL 基础学习</a><a href="/tags/PostgreSQL-案例/" style="font-size: 10.00px;">PostgreSQL 案例</a><a href="/tags/PostgreSQL-翻译/" style="font-size: 12.50px;">PostgreSQL 翻译</a><a href="/tags/PostgreSQL-读书笔记/" style="font-size: 15.00px;">PostgreSQL 读书笔记</a><a href="/tags/临时表/" style="font-size: 10.00px;">临时表</a><a href="/tags/博客/" style="font-size: 10.00px;">博客</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/12/12/-翻译-CTE表达式和临时表的区别/">[翻译]CTE表达式和临时表的区别</a>
          </li>
        
          <li>
            <a href="/2014/12/09/-翻译-MySQL与PostgreSQL9-0的复制功能对比/">[翻译]MySQL与PostgreSQL9.0的复制功能对比</a>
          </li>
        
          <li>
            <a href="/2014/12/08/PostgreSQL窗口函数/">PostgreSQL窗口函数</a>
          </li>
        
          <li>
            <a href="/2014/12/05/PostgreSQL选择某组sum结果最小的所有数据/">PostgreSQL选择某组sum结果最小的所有数据</a>
          </li>
        
          <li>
            <a href="/2014/12/04/PostgreSQL-进程构架/">PostgreSQL 进程构架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 Zhiyong yang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>